package flat/parser

import flat/datastruct/HashMap
import flat/parser/Parser
import flat/annotations/VisibleModifier
import flat/annotations/PublicModifier
import flat/annotations/PrivateModifier
import flat/annotations/LetModifier
import flat/annotations/VarModifier
import flat/ast/FileNode
import flat/ast/PackageNode
import flat/compiler/models/Token
import flat/io/File

testable class {
  async test `can match package matcher group`() {
    let groupPattern = GroupTokenPattern([
      SingleTokenPattern(Token.Type.IDENTIFIER, "package"),
      SingleTokenPattern(Token.Type.IDENTIFIER, label: "package_location_component")
    ])

    let result = groupPattern
      .getMatcher()
      .matchAll([
        Token(value: "package", type: Token.Type.IDENTIFIER),
        Token(value: "test", type: Token.Type.IDENTIFIER)
      ])
      .last

    expect(result?.getValues("package_location_component")).toBe(["test"])
  }

  async test `can match package matcher group with unmatched optional repeating package_location_component`() {
    let groupPattern = GroupTokenPattern([
      SingleTokenPattern(Token.Type.IDENTIFIER, "package"),
      SingleTokenPattern(Token.Type.IDENTIFIER, label: "package_location_component"),
      GroupTokenPattern([
        SingleTokenPattern(Token.Type.SYMBOL, "/", label: "package_location_component"),
        SingleTokenPattern(Token.Type.IDENTIFIER, label: "package_location_component")
      ], repeat: true, optional: true)
    ])

    let result = groupPattern
      .getMatcher()
      .matchAll([
        Token(value: "package", type: Token.Type.IDENTIFIER),
        Token(value: "test", type: Token.Type.IDENTIFIER)
      ])
      .last

    expect(result?.getValues("package_location_component")).toBe(["test"])
  }

  async test `can match package matcher group with matched optional repeating package_location_component`() {
    let groupPattern = GroupTokenPattern([
      SingleTokenPattern(Token.Type.IDENTIFIER, "package"),
      SingleTokenPattern(Token.Type.IDENTIFIER, label: "package_location_component"),
      GroupTokenPattern([
        SingleTokenPattern(Token.Type.SYMBOL, "/", label: "package_location_component"),
        SingleTokenPattern(Token.Type.IDENTIFIER, label: "package_location_component")
      ], repeat: true, optional: true)
    ])

    let result = groupPattern
      .getMatcher()
      .matchAll([
        Token(value: "package", type: Token.Type.IDENTIFIER),
        Token(value: "test", type: Token.Type.IDENTIFIER),
        Token(value: "/", type: Token.Type.SYMBOL),
        Token(value: "thing", type: Token.Type.IDENTIFIER),
        Token(value: "/", type: Token.Type.SYMBOL),
        Token(value: "thing2", type: Token.Type.IDENTIFIER)
      ])
      .last

    expect(result?.getValues("package_location_component")).toBe(["test", "/", "thing", "/", "thing2"])
  }

  async test `can match multiple nested matcher groups with matched optional repeating values`() {
    let groupPattern = GroupTokenPattern([
      SingleTokenPattern(Token.Type.IDENTIFIER, "class"),
      SingleTokenPattern(Token.Type.IDENTIFIER, label: "class_name", optional: true, greedy: false),
      GroupTokenPattern([
        SingleTokenPattern(Token.Type.IDENTIFIER, "extends"),
        SingleTokenPattern(Token.Type.IDENTIFIER, label: "extends_class_name")
      ], optional: true),
      GroupTokenPattern([
        SingleTokenPattern(Token.Type.IDENTIFIER, "implements"),
        SingleTokenPattern(Token.Type.IDENTIFIER, label: "implements_class_name"),
        GroupTokenPattern([
          SingleTokenPattern(Token.Type.SYMBOL, ","),
          SingleTokenPattern(Token.Type.IDENTIFIER, label: "implements_class_name")
        ], repeat: true, optional: true)
      ], optional: true)
    ])

    let result = groupPattern
      .getMatcher()
      .matchAll([
        Token(value: "class", type: Token.Type.IDENTIFIER),
        Token(value: "extends", type: Token.Type.IDENTIFIER),
        Token(value: "Extended", type: Token.Type.IDENTIFIER),
        Token(value: "implements", type: Token.Type.IDENTIFIER),
        Token(value: "I1", type: Token.Type.IDENTIFIER),
        Token(value: ",", type: Token.Type.SYMBOL),
        Token(value: "I2", type: Token.Type.IDENTIFIER),
        Token(value: ",", type: Token.Type.SYMBOL),
        Token(value: "I3", type: Token.Type.IDENTIFIER)
      ])
      .last

    expect(result?.getValues("class_name")).toBe(Array())
    expect(result?.getValues("extends_class_name")).toBe(["Extended"])
    expect(result?.getValues("implements_class_name")).toBe(["I1", "I2", "I3"])
  }

  async test `can match multiple nested matcher groups with matched optional repeating values where the non-greedy value is matched`() {
    let groupPattern = GroupTokenPattern([
      SingleTokenPattern(Token.Type.IDENTIFIER, "class"),
      SingleTokenPattern(Token.Type.IDENTIFIER, label: "class_name", optional: true, greedy: false),
      GroupTokenPattern([
        SingleTokenPattern(Token.Type.IDENTIFIER, "extends"),
        SingleTokenPattern(Token.Type.IDENTIFIER, label: "extends_class_name")
      ], optional: true),
      GroupTokenPattern([
        SingleTokenPattern(Token.Type.IDENTIFIER, "implements"),
        SingleTokenPattern(Token.Type.IDENTIFIER, label: "implements_class_name"),
        GroupTokenPattern([
          SingleTokenPattern(Token.Type.SYMBOL, ","),
          SingleTokenPattern(Token.Type.IDENTIFIER, label: "implements_class_name")
        ], repeat: true, optional: true)
      ], optional: true)
    ])

    let result = groupPattern
      .getMatcher()
      .matchAll([
        Token(value: "class", type: Token.Type.IDENTIFIER),
        Token(value: "Bob", type: Token.Type.IDENTIFIER),
        Token(value: "extends", type: Token.Type.IDENTIFIER),
        Token(value: "Extended", type: Token.Type.IDENTIFIER),
        Token(value: "implements", type: Token.Type.IDENTIFIER),
        Token(value: "I1", type: Token.Type.IDENTIFIER),
        Token(value: ",", type: Token.Type.SYMBOL),
        Token(value: "I2", type: Token.Type.IDENTIFIER),
        Token(value: ",", type: Token.Type.SYMBOL),
        Token(value: "I3", type: Token.Type.IDENTIFIER)
      ])
      .last

    expect(result?.getValues("class_name")).toBe(["Bob"])
    expect(result?.getValues("extends_class_name")).toBe(["Extended"])
    expect(result?.getValues("implements_class_name")).toBe(["I1", "I2", "I3"])
  }

  async test `can match against matcher with multiple values`() {
    let groupPattern = GroupTokenPattern([
      SingleTokenPattern(Token.Type.IDENTIFIER, label: "alias", values: Array():addAll([
          "test1", "test2", "test3", "test4"
        ])
      )
    ])

    let result = groupPattern
      .getMatcher()
      .matchAll([
        Token(value: "test3", type: Token.Type.IDENTIFIER)
      ])
      .last

    expect(result?.getValues("alias")).toBe(["test3"])
  }

  async test `can match partially against matcher when too few tokens given`() {
    let groupPattern = GroupTokenPattern([
      SingleTokenPattern(Token.Type.IDENTIFIER, "package"),
      SingleTokenPattern(Token.Type.IDENTIFIER, label: "package_location_component"),
      GroupTokenPattern([
        SingleTokenPattern(Token.Type.SYMBOL, "/", label: "package_location_component"),
        SingleTokenPattern(Token.Type.IDENTIFIER, label: "package_location_component")
      ], repeat: true, optional: true)
    ])

    let matcher = groupPattern.getMatcher()

    let result = matcher
      .matchAll([
        Token(value: "package", type: Token.Type.IDENTIFIER)
      ])
      .last

    expect(result).toBe(null)
    expect(matcher.partial).toBe(true)
  }

  async test `doesnt match partially against matcher when too few and incorrect tokens given`() {
    let groupPattern = GroupTokenPattern([
      SingleTokenPattern(Token.Type.IDENTIFIER, "import"),
      SingleTokenPattern(Token.Type.IDENTIFIER, label: "import_location_component"),
      GroupTokenPattern([
        SingleTokenPattern(Token.Type.SYMBOL, "/", label: "import_location_component"),
        SingleTokenPattern(Token.Type.IDENTIFIER, label: "import_location_component")
      ], repeat: true, optional: true)
    ])

    let matcher = groupPattern.getMatcher()

    let result = matcher
      .matchAll([
        Token(value: "package", type: Token.Type.IDENTIFIER)
      ])
      .last

    expect(result).toBe(null)
    expect(matcher.partial).toBe(false)
  }

  async test `doesnt match partially against matcher when too many tokens that dont match are given`() {
    let groupPattern = GroupTokenPattern([
      SingleTokenPattern(Token.Type.IDENTIFIER, "class"),
      SingleTokenPattern(Token.Type.IDENTIFIER, label: "class_name", optional: true, greedy: false),
      GroupTokenPattern([
        SingleTokenPattern(Token.Type.IDENTIFIER, "extends"),
        SingleTokenPattern(Token.Type.IDENTIFIER, label: "extends_class_name")
      ], optional: true),
      GroupTokenPattern([
        SingleTokenPattern(Token.Type.IDENTIFIER, "implements"),
        SingleTokenPattern(Token.Type.IDENTIFIER, label: "implements_class_name"),
        GroupTokenPattern([
          SingleTokenPattern(Token.Type.SYMBOL, ","),
          SingleTokenPattern(Token.Type.IDENTIFIER, label: "implements_class_name")
        ], repeat: true, optional: true)
      ], optional: true)
    ])

    let matcher = groupPattern.getMatcher()
    let result = matcher.matchAll([
      Token(value: "class", type: Token.Type.IDENTIFIER),
      Token(value: "{", type: Token.Type.SYMBOL),
      Token(value: "public", type: Token.Type.IDENTIFIER),
      Token(value: "static", type: Token.Type.IDENTIFIER),
      Token(value: "async", type: Token.Type.IDENTIFIER),
      Token(value: "main", type: Token.Type.IDENTIFIER),
      Token(value: "(", type: Token.Type.SYMBOL),
      Token(value: "String", type: Token.Type.IDENTIFIER),
      Token(value: "[", type: Token.Type.SYMBOL),
      Token(value: "]", type: Token.Type.SYMBOL),
      Token(value: "args", type: Token.Type.IDENTIFIER),
      Token(value: ")", type: Token.Type.SYMBOL),
      Token(value: "{", type: Token.Type.SYMBOL)
    ]).last

    expect(result).toBe(null)
    expect(matcher.partial).toBe(false)
  }

  async test `matches against just first identifier if all others are optional`() {
    let groupPattern = GroupTokenPattern([
      SingleTokenPattern(Token.Type.IDENTIFIER, "class"),
      SingleTokenPattern(Token.Type.IDENTIFIER, label: "class_name", optional: true, greedy: false),
      GroupTokenPattern([
        SingleTokenPattern(Token.Type.IDENTIFIER, "extends"),
        SingleTokenPattern(Token.Type.IDENTIFIER, label: "extends_class_name")
      ], optional: true),
      GroupTokenPattern([
        SingleTokenPattern(Token.Type.IDENTIFIER, "implements"),
        SingleTokenPattern(Token.Type.IDENTIFIER, label: "implements_class_name"),
        GroupTokenPattern([
          SingleTokenPattern(Token.Type.SYMBOL, ","),
          SingleTokenPattern(Token.Type.IDENTIFIER, label: "implements_class_name")
        ], repeat: true, optional: true)
      ], optional: true)
    ])

    let matcher = groupPattern.getMatcher()
    let result = matcher.match(Token(value: "class", type: Token.Type.IDENTIFIER))

    let expected = [Token(value: "class", type: Token.Type.IDENTIFIER)]

    expect(result?.tokens).toBe(expected)
    expect(matcher.partial).toBe(true)
  }

  async test `matches completely against multiple entry options`() {
    let groupPattern = GroupTokenPattern([
      GroupTokenPattern([
        SingleTokenPattern(Token.Type.SYMBOL, "["),
        SingleTokenPattern(Token.Type.IDENTIFIER, label: "identifier"),
        SingleTokenPattern(Token.Type.SYMBOL, "]")
      ], optional: true),
      GroupTokenPattern([
        GroupTokenPattern([
          SingleTokenPattern(Token.Type.IDENTIFIER, label: "alias", values: Array()
            :addAll(VisibleModifier.aliases)
            :addAll(PublicModifier.aliases)
            :addAll(PrivateModifier.aliases)
            :addAll(LetModifier.aliases)
            :addAll(VarModifier.aliases)
          )
        ])
      ], optional: true)
    ])

    let matcher = groupPattern.getMatcher()
    let result = matcher.match(Token(value: "public", type: Token.Type.IDENTIFIER))

    let expected = [Token(value: "public", type: Token.Type.IDENTIFIER)]

    expect(result?.tokens).toBe(expected)
    expect(matcher.partial).toBe(false)
  }

  async test `doesnt match complete single array bracket in annotation matcher`() {
    let groupPattern = GroupTokenPattern([
      GroupTokenPattern([
        SingleTokenPattern(Token.Type.SYMBOL, "["),
        SingleTokenPattern(Token.Type.IDENTIFIER, label: "identifier"),
        SingleTokenPattern(Token.Type.SYMBOL, "]")
      ], optional: true),
      GroupTokenPattern([
        GroupTokenPattern([
          SingleTokenPattern(Token.Type.IDENTIFIER, label: "alias", values: Array()
            :addAll(VisibleModifier.aliases)
            :addAll(PublicModifier.aliases)
            :addAll(PrivateModifier.aliases)
            :addAll(LetModifier.aliases)
            :addAll(VarModifier.aliases)
          )
        ])
      ], optional: true)
    ])

    let matcher = groupPattern.getMatcher()
    let result = matcher.match(Token(value: "[", type: Token.Type.SYMBOL))

    let expected = [Token(value: "[", type: Token.Type.SYMBOL)]

    expect(matcher.tokens).toBe(expected)
    expect(matcher.partial).toBe(true)
  }

  async test `doesnt match ending part of annotation`() {
    let groupPattern = GroupTokenPattern([
      GroupTokenPattern([
        SingleTokenPattern(Token.Type.SYMBOL, "["),
        SingleTokenPattern(Token.Type.IDENTIFIER, label: "identifier"),
        SingleTokenPattern(Token.Type.SYMBOL, "]")
      ], optional: true),
      GroupTokenPattern([
        GroupTokenPattern([
          SingleTokenPattern(Token.Type.IDENTIFIER, label: "alias", values: Array()
            :addAll(VisibleModifier.aliases)
            :addAll(PublicModifier.aliases)
            :addAll(PrivateModifier.aliases)
            :addAll(LetModifier.aliases)
            :addAll(VarModifier.aliases)
          )
        ])
      ], optional: true)
    ])

    let matcher = groupPattern.getMatcher()
    let result = matcher.matchAll([
      Token(value: "1", type: Token.Type.INTEGER),
      Token(value: "]", type: Token.Type.SYMBOL)
    ]).last

    expect(result).toBe(null)
  }

  async test `can match complete multiple captures with nested contents`() {
    let groupPattern = GroupTokenPattern([
      CaptureTokenPattern(
        start: Token(value: "<"),
        end: Token(value: ">")
      ),
      CaptureTokenPattern(
        start: Token(value: "("),
        end: Token(value: ")")
      )
    ])

    let matcher = groupPattern.getMatcher()
    let result = matcher.matchAll([
      Token(value: "<", type: Token.Type.SYMBOL),
      Token(value: "bob", type: Token.Type.IDENTIFIER),
      Token(value: ">", type: Token.Type.SYMBOL),
      Token(value: "(", type: Token.Type.SYMBOL),
      Token(value: "saget", type: Token.Type.IDENTIFIER),
      Token(value: ")", type: Token.Type.SYMBOL)
    ]).last

    let expected = [
      Token(value: "<", type: Token.Type.SYMBOL),
      Token(value: "bob", type: Token.Type.IDENTIFIER),
      Token(value: ">", type: Token.Type.SYMBOL),
      Token(value: "(", type: Token.Type.SYMBOL),
      Token(value: "saget", type: Token.Type.IDENTIFIER),
      Token(value: ")", type: Token.Type.SYMBOL)
    ]

    expect(result?.tokens).toBe(expected)
    expect(matcher.partial).toBe(false)
  }

  async test `can match partial multiple captures with nested contents`() {
    let groupPattern = GroupTokenPattern([
      CaptureTokenPattern(
        start: Token(value: "<"),
        end: Token(value: ">")
      ),
      CaptureTokenPattern(
        start: Token(value: "("),
        end: Token(value: ")")
      )
    ])

    let matcher = groupPattern.getMatcher()
    let result = matcher.matchAll([
      Token(value: "<", type: Token.Type.SYMBOL),
      Token(value: "bob", type: Token.Type.IDENTIFIER),
      Token(value: ">", type: Token.Type.SYMBOL),
      Token(value: "(", type: Token.Type.SYMBOL),
      Token(value: "saget", type: Token.Type.IDENTIFIER),
      Token(value: "(", type: Token.Type.SYMBOL)
    ])

    let expected = [
      Token(value: "<", type: Token.Type.SYMBOL),
      Token(value: "bob", type: Token.Type.IDENTIFIER),
      Token(value: ">", type: Token.Type.SYMBOL),
      Token(value: "(", type: Token.Type.SYMBOL),
      Token(value: "saget", type: Token.Type.IDENTIFIER),
      Token(value: "(", type: Token.Type.SYMBOL)
    ]

    expect(matcher.tokens).toBe(expected)
    expect(matcher.partial).toBe(true)
  }
}
