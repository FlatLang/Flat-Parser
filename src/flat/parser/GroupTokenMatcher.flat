package flat/parser

import flat/datastruct/HashMap
import flat/datastruct/list/Queue
import flat/datastruct/list/Stack
import flat/datastruct/list/ArrayIterator
import flat/compiler/models/Token
import flat/log/Logger

import static flat/colorizer/Colorizer

data class extends TokenMatcher {
  let static Logger log = Logger(GroupTokenMatcher.class)

  GroupTokenPattern pattern

  lazy ArrayIterator<TokenMatcher> iterator => pattern.patterns.map({ _.getMatcher() }).iterator
  lazy Stack<TokenMatcher> nonGreedyMatchers => Stack()

  lazy TokenMatch[] successfulMatches => TokenMatch[]

  var TokenMatcher lastMatcher
  var TokenMatcher matcher
  var Bool nonGreedyChecked = false
  var Token[] successfulMatchedTokens = Token[]

  nextMatcher() {
    while (nonGreedyMatchers.isNotEmpty) {
      log.traceFunc({"Popping nonGreedyMatcher"})
      nonGreedyMatchers.pop()
      iterator.stepNext
    }

    nonGreedyChecked = false
    matcher = iterator.stepNext
  }

  repeatMatcher() {
    log.traceFunc({"Repeating matcher"})
    matcher = matcher.pattern.getMatcher()
  }

  addSuccessfulMatch(TokenMatch tokenMatch) {
    if (!Object.referenceEquals(matcher, lastMatcher)) {
      successfulMatches.add(tokenMatch)
    } else {
      successfulMatches[successfulMatches.count - 1] = tokenMatch
    }
    lastMatcher = matcher
    successfulMatchedTokens.addAll(tokenMatch.tokens)
  }

  override public match(Token token, ParseContext context = null) => tokenMatches.add(doMatch(token, context))

  doMatch(Token token, ParseContext context) -> TokenMatch => null {
    if (disqualified) return null
    if (tokens.isEmpty) {
      if (iterator.hasNext) {
        nextMatcher()
      } else {
        disqualified = true
        return null
      }
    }
    if (!matcher) {
      disqualified = true
      return null
    }

    tokens.add(token)

    return this.match(context)
  }

  match(ParseContext context) -> TokenMatch => null {
    let token = tokens.last

    log.traceFunc({"|
      Matching tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ")}]
        pattern: #{magenta(matcher.pattern.toPatternString())}
      |"})

    if (matcher.pattern.optional && !matcher.pattern.greedy && !nonGreedyChecked) {
      if (iterator.hasNext) {
        log.traceFunc({"Checking next matcher because current matcher is non-greedy optional"})
        nonGreedyMatchers.push(matcher)
        matcher = iterator.next.copy()
      } else {
        log.traceFunc({"No other matchers to match. Skipping greedy check"})
      }
    }

    if (let tokenMatch = matcher.match(token, context)) {
      return handleSuccessfulMatch(tokenMatch, context)
    } else if (matcher.partial) {
      log.traceFunc({"Returning null for partial match. matcher: " + magenta(matcher.pattern.toPatternString())})
      return null
    } else if (nonGreedyMatchers.isNotEmpty) {
      log.traceFunc({"Did not match the non-greedy matcher check. Reverting back to before non-greedy check"})
      let tokensToMatch = matcher.tokens
      tokensToMatch.forEach({ tokens.removeLast() })
      matcher = nonGreedyMatchers.pop()
      nonGreedyChecked = true
      return tokensToMatch.map({
        tokens.add(_)
        return this.match(context)
      }).last
    } else if (matcher.pattern.optional && iterator.hasNext) {
      nextMatcher()
      log.traceFunc({"Did not match the optional matcher. Skipped to next matcher: " + magenta(matcher.pattern.toPatternString())})
      return this.match(context)
    } else {
      log.traceFunc({"|
        Did not match the required matcher. Disqualified
          pattern: #{magenta(matcher.pattern.toPatternString())}
        |"})
      disqualified = true
      return null
    }
  }

  handleSuccessfulMatch(TokenMatch tokenMatch, ParseContext context) -> GroupTokenMatch {
    log.traceFunc({"|
      Matched tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ")}]
        matched tokens: [#{tokenMatch.tokens.map(t => "'" + green(t.value) + "'").join(", ")}]
        pattern: #{magenta(matcher.pattern.toPatternString())}
      |"})
    addSuccessfulMatch(tokenMatch)

    if (let remainingMatch = checkRemainingMatch(tokenMatch, context)) {
      return remainingMatch
    }

    if (matcher.pattern.repeat && matcher.complete) { // Should this be `matcher.disqualified`?
      repeatMatcher()
      if (iterator.allNext.any({ !_.pattern.optional })) {
        log.traceFunc({"Contains future required matchers. Returning null"})
        return null
      } else {
        log.traceFunc({"The rest of the matchers are optional. Returning match"})
      }
    } else if (iterator.hasNext) {
      if (!matcher.complete) { // FIXME: handle non-greedy
        if (iterator.allNext.any({ !_.pattern.optional })) {
          log.traceFunc({"Contains future required matchers. Returning null"})
          return null
        } else {
          log.traceFunc({"The rest of the matchers are optional. Returning match"})
        }
      } else {
        nextMatcher()
        if (iterator.allNextInclusive.all({ _.pattern.optional })) {
          log.traceFunc({"The rest of the matchers are optional. Returning match and skipped to next matcher: " + magenta(matcher.pattern.toPatternString())})
          valid = true
        } else {
          log.traceFunc({"There are still some required matchers. Returning null and skipped to next matcher: " + magenta(matcher.pattern.toPatternString())})
          return null
        }
      }
    } else {
      log.traceFunc({"No more matchers. Returning match. Disqualified: #{matcher.disqualified}. Complete: #{matcher.complete}"})
      disqualified = matcher.disqualified
      valid = matcher.valid
      complete = matcher.complete
    }

    return GroupTokenMatch(
      tokens: tokens.copy(),
      tokenMatches: successfulMatches.copy(),
      label: pattern.label
    )
  }

  checkRemainingMatch(TokenMatch tokenMatch, ParseContext context) -> GroupTokenMatch => null {
    let containsRemainingTokens = successfulMatchedTokens.count < tokens.count

    if (containsRemainingTokens) {
      let tokensToMatch = tokens.skip(successfulMatchedTokens.count)
      log.traceFunc({"|
        Contains remaining tokens from partial match: [#{tokensToMatch.map(t => "'" + green(t.value) + "'").join(", ")}]
          successfulMatchedTokens: [#{successfulMatchedTokens.map(t => "'" + green(t.value) + "'").join(", ")}]
          tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ")}]
        |"})
      tokensToMatch.forEach({ tokens.removeLast() })

      if (matcher.pattern.repeat && matcher.complete) { // Should this be `matcher.disqualified`?
        repeatMatcher()
      } else if (iterator.hasNext && matcher.complete) { // FIXME: handle non-greedy
        nextMatcher()
        log.traceFunc({"Skipped to next matcher: " + magenta(matcher.pattern.toPatternString())})
      }

      log.traceFunc({"Iterating through tokens: [#{tokensToMatch.map(t => "'" + green(t.value) + "'").join(", ")}]"})
      tokensToMatch.forEach({
        tokens.add(_)
        return this.match(context)
      })
      log.traceFunc({"Returning composite group token match"})
      return GroupTokenMatch(
        tokens: successfulMatchedTokens.copy(),
        tokenMatches: successfulMatches.copy(),
        label: pattern.label
      )
    } else {
      log.traceFunc({"No partial match remaining tokens"})
    }
  }

  override public reset() {
    if (matcher == null) return
    log.traceFunc({"Resetting matcher"})
    super.reset()

    iterator.reset()
    iterator.allNextInclusive.forEach({ _.reset() })
    nonGreedyMatchers.clear()
    successfulMatches.clear()
    successfulMatchedTokens = Token[]
    lastMatcher = null
    matcher = null
    nonGreedyChecked = false
  }
}