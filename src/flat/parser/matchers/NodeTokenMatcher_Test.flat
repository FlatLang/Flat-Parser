package flat/parser/matchers

import flat/parser
import flat/datastruct/HashMap
import flat/parser/Parser
import flat/annotations/VisibleModifier
import flat/annotations/PublicModifier
import flat/annotations/PrivateModifier
import flat/annotations/LetModifier
import flat/annotations/VarModifier
import flat/ast/FileNode
import flat/ast/PackageNode
import flat/ast/IdentifierNode
import flat/ast/DotAccessNode
import flat/ast/ArrayAccessNode
import flat/compiler/models/Token
import flat/io/File

testable class {
  test `can match partial import parser`() {
    let importParser = ImportParser()
    let pattern = NodeTokenPattern([importParser])

    let matcher = pattern.getMatcher()
    let result = matcher.match(Token(value: "import", type: Token.Type.IDENTIFIER))

    expect(result).toBe(null)
    expect(matcher.partial).toBe(true)
  }

  test `can match complete import parser`() {
    let importParser = ImportParser()
    let pattern = NodeTokenPattern([importParser])

    let matcher = pattern.getMatcher()
    let result = matcher.matchAll([
      Token(value: "import", type: Token.Type.IDENTIFIER),
      Token(value: "test", type: Token.Type.IDENTIFIER)
    ]).last

    let expected = [
      Token(value: "import", type: Token.Type.IDENTIFIER),
      Token(value: "test", type: Token.Type.IDENTIFIER)
    ]

    expect(result?.tokens).toBe(expected)
    expect(matcher.partial).toBe(true)
  }

  test `doesnt match package token when not using package parser`() {
    let importParser = ImportParser()
    let pattern = NodeTokenPattern([importParser])

    let matcher = pattern.getMatcher()
    let result = matcher.match(Token(value: "package", type: Token.Type.IDENTIFIER))

    expect(result).toBe(null)
  }

  test `matches full import parser`() {
    let pattern = NodeTokenPattern([ImportParser()])

    let matcher = pattern.getMatcher()
    let result = matcher
      :match(Token(value: "import", type: Token.Type.IDENTIFIER))
      .match(Token(value: "test", type: Token.Type.IDENTIFIER))

    expect(result?.parser).toBe(ImportParser())
  }

  test `can match correctly in a group token pattern`() {
    let pattern = GroupTokenPattern([
      NodeTokenPattern([ParameterParser()], label: "node_match"),
      SingleTokenPattern(Token.Type.SYMBOL, ",")
    ])

    let matcher = pattern.getMatcher()
    let result = matcher.matchAll([
      Token(value: "String", type: Token.Type.IDENTIFIER),
      Token(value: "test", type: Token.Type.IDENTIFIER),
      Token(value: ",", type: Token.Type.SYMBOL)
    ]).last

    expect(result).toBe(
      GroupTokenMatch(
        tokens: [
          Token(value: "String", type: Token.Type.IDENTIFIER),
          Token(value: "test", type: Token.Type.IDENTIFIER),
          Token(value: ",", type: Token.Type.SYMBOL)
        ],
        tokenMatches: [
          NodeTokenMatch(
            tokens: [
              Token(value: "String", type: Token.Type.IDENTIFIER),
              Token(value: "test", type: Token.Type.IDENTIFIER)
            ],
            parser: ParameterParser(),
            childMatches: Array(),
            label: "node_match"
          ),
          SingleTokenMatch(tokens: [Token(value: ",", type: Token.Type.SYMBOL)])
        ]
      )
    )
  }

  test `can match correctly in a group token pattern and get node`() {
    let pattern = GroupTokenPattern([
      NodeTokenPattern([ParameterParser()], label: "parameter"),
      SingleTokenPattern(Token.Type.SYMBOL, ",")
    ])

    let matcher = pattern.getMatcher()
    let match = matcher.matchAll([
      Token(value: "String", type: Token.Type.IDENTIFIER),
      Token(value: "test", type: Token.Type.IDENTIFIER),
      Token(value: ",", type: Token.Type.SYMBOL)
    ]).last

    expect(match).toNotBe(null)

    let result = ParameterParser().generateNode(null, match.getMatch("parameter"))

    expect(result).toBe(
      ParameterNode(
        type: "String",
        name: "test"
      )
    )
  }

  test `can match a parameter in parentheses`() {
    let pattern = GroupTokenPattern([
      SingleTokenPattern(Token.Type.SYMBOL, "("),
      NodeTokenPattern([ParameterParser()], label: "parameter"),
      GroupTokenPattern([
        SingleTokenPattern(Token.Type.SYMBOL, ","),
        NodeTokenPattern([ParameterParser()], label: "parameter")
      ], optional: true, repeat: true),
      SingleTokenPattern(Token.Type.SYMBOL, ")")
    ])

    let matcher = pattern.getMatcher()
    let match = matcher.matchAll([
      Token(value: "(", type: Token.Type.SYMBOL),
      Token(value: "String", type: Token.Type.IDENTIFIER),
      Token(value: "test", type: Token.Type.IDENTIFIER),
      Token(value: ")", type: Token.Type.SYMBOL)
    ]).last

    expect(match).toNotBe(null)

    let result = ParameterParser().generateNode(null, match.getMatch("parameter"))

    expect(result).toBe(
      ParameterNode(
        type: "String",
        name: "test"
      )
    )
  }

  test `can match a parameter with array brackets in parentheses`() {
    let pattern = GroupTokenPattern([
      SingleTokenPattern(Token.Type.SYMBOL, "("),
      NodeTokenPattern([ParameterParser()], label: "parameter"),
      GroupTokenPattern([
        SingleTokenPattern(Token.Type.SYMBOL, ","),
        NodeTokenPattern([ParameterParser()], label: "parameter")
      ], optional: true, repeat: true),
      SingleTokenPattern(Token.Type.SYMBOL, ")")
    ])

    let matcher = pattern.getMatcher()
    let match = matcher.matchAll([
      Token(value: "(", type: Token.Type.SYMBOL),
      Token(value: "String", type: Token.Type.IDENTIFIER),
      Token(value: "[", type: Token.Type.SYMBOL),
      Token(value: "]", type: Token.Type.SYMBOL),
      Token(value: "test", type: Token.Type.IDENTIFIER),
      Token(value: ")", type: Token.Type.SYMBOL)
    ]).last

    expect(match).toNotBe(null)

    let result = ParameterParser().generateNode(null, match.getMatch("parameter"))

    expect(result).toBe(
      ParameterNode(
        type: "String",
        name: "test",
        arrayDimensions: 1
      )
    )
  }

  test `can match a multi-node expression`() {
    let pattern = NodeTokenPattern([IdentifierParser()], label: "argument")

    let matcher = pattern.getMatcher()
    matcher.matchAll([
      Token(value: "thing", type: Token.Type.IDENTIFIER),
      Token(value: ".", type: Token.Type.SYMBOL),
      Token(value: "otherThing", type: Token.Type.IDENTIFIER)
    ])

    let match = matcher.lastMatch

    expect(match).toNotBe(null, "match was null")

    expect(match).toBe(
      NodeTokenMatch(
        label: "argument",
        tokens: [
          Token(value: "thing", type: Token.Type.IDENTIFIER),
          Token(value: ".", type: Token.Type.SYMBOL),
          Token(value: "otherThing", type: Token.Type.IDENTIFIER)
        ],
        parser: IdentifierParser(),
        childMatches: [
          NodeTokenMatch(
            tokens: [Token(value: ".", type: Token.Type.SYMBOL)],
            parser: DotAccessParser()
          ),
          NodeTokenMatch(
            tokens: [Token(value: "otherThing", type: Token.Type.IDENTIFIER)],
            parser: IdentifierParser()
          )
        ]
      )
    )
  }

  test `can generate nodes for a multi-node expression`() {
    let pattern = NodeTokenPattern([IdentifierParser()], label: "argument")

    let matcher = pattern.getMatcher()
    matcher.matchAll([
      Token(value: "thing", type: Token.Type.IDENTIFIER),
      Token(value: ".", type: Token.Type.SYMBOL),
      Token(value: "otherThing", type: Token.Type.IDENTIFIER)
    ])

    let match = matcher.lastMatch

    expect(match).toNotBe(null, "match was null")

    let nodeMatch = match.getMatch<NodeTokenMatch>("argument")

    expect(nodeMatch).toNotBe(null, "nodeMatch was null")

    let result = nodeMatch.generateNodes(ParseContext())

    expect(result).toBe([
      IdentifierNode(name: "thing"),
      DotAccessNode(),
      IdentifierNode(name: "otherThing")
    ])
  }

  test `can backtrack to a successful match and continue with children`() {
    let pattern = NodeTokenPattern([IdentifierParser(), LocalDeclarationParser()], label: "argument")

    let matcher = pattern.getMatcher()
    matcher.matchAll([
      Token(value: "thing", type: Token.Type.IDENTIFIER),
      Token(value: "[", type: Token.Type.SYMBOL),
      Token(value: "otherThing", type: Token.Type.IDENTIFIER),
      Token(value: "]", type: Token.Type.SYMBOL)
    ], ParseContext())

    let match = matcher.lastMatch

    expect(match).toNotBe(null, "match was null")

    let nodeMatch = match.getMatch<NodeTokenMatch>("argument")

    expect(nodeMatch).toNotBe(null, "nodeMatch was null")

    let result = nodeMatch.generateNodes(ParseContext())

    expect(result).toBe([
      IdentifierNode(name: "thing"),
      ArrayAccessNode(),
      IdentifierNode(name: "otherThing")
    ])
  }
}
