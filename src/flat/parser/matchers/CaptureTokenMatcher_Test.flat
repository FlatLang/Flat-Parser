package flat/parser/matchers

import flat/parser
import flat/parser/parsers
import flat/datastruct/HashMap
import flat/parser/Parser
import flat/annotations/VisibleModifier
import flat/annotations/PublicModifier
import flat/annotations/PrivateModifier
import flat/annotations/LetModifier
import flat/annotations/VarModifier
import flat/ast/FileNode
import flat/ast/PackageNode
import flat/compiler/models/Token
import flat/io/File

testable class {
  test `can match parentheses capture`() {
    let capturePattern = CaptureTokenPattern(
      start: Token(value: "("),
      end: Token(value: ")")
    )

    let matcher = capturePattern.getMatcher()
    let result = matcher.matchAll([
      Token(value: "(", type: Token.Type.SYMBOL),
      Token(value: "hey", type: Token.Type.IDENTIFIER),
      Token(value: ")", type: Token.Type.SYMBOL)
    ]).last

    let expected = CaptureTokenMatch(
      tokens: [
        Token(value: "(", type: Token.Type.SYMBOL),
        Token(value: "hey", type: Token.Type.IDENTIFIER),
        Token(value: ")", type: Token.Type.SYMBOL)
      ],
      capture: [Token(value: "hey", type: Token.Type.IDENTIFIER)]
    )

    expect(result).toBe(expected)
    expect(matcher.partial).toBe(false)
  }

  test `can match partial parentheses capture no with contents`() {
    let capturePattern = CaptureTokenPattern(
      start: Token(value: "("),
      end: Token(value: ")")
    )

    let matcher = capturePattern.getMatcher()
    let result = matcher.matchAll([
      Token(value: "(", type: Token.Type.SYMBOL)
    ]).last

    let expected = [Token(value: "(", type: Token.Type.SYMBOL)]

    expect(matcher.tokens).toBe(expected)
    expect(matcher.partial).toBe(true)
  }

  test `can match partial parentheses capture with contents`() {
    let capturePattern = CaptureTokenPattern(
      start: Token(value: "("),
      end: Token(value: ")")
    )

    let matcher = capturePattern.getMatcher()
    let result = matcher.matchAll([
      Token(value: "(", type: Token.Type.SYMBOL),
      Token(value: "hey", type: Token.Type.IDENTIFIER)
    ]).last

    let expected = [
      Token(value: "(", type: Token.Type.SYMBOL),
      Token(value: "hey", type: Token.Type.IDENTIFIER)
    ]

    expect(matcher.tokens).toBe(expected)
    expect(matcher.partial).toBe(true)
  }

  test `can match partial parentheses capture with nested parentheses contents`() {
    let capturePattern = CaptureTokenPattern(
      start: Token(value: "("),
      end: Token(value: ")")
    )

    let matcher = capturePattern.getMatcher()
    let result = matcher.matchAll([
      Token(value: "(", type: Token.Type.SYMBOL),
      Token(value: "hey", type: Token.Type.IDENTIFIER),
      Token(value: "(", type: Token.Type.SYMBOL),
      Token(value: "(", type: Token.Type.SYMBOL),
      Token(value: "(", type: Token.Type.SYMBOL)
    ]).last

    let expected = [
      Token(value: "(", type: Token.Type.SYMBOL),
      Token(value: "hey", type: Token.Type.IDENTIFIER),
      Token(value: "(", type: Token.Type.SYMBOL),
      Token(value: "(", type: Token.Type.SYMBOL),
      Token(value: "(", type: Token.Type.SYMBOL)
    ]

    expect(matcher.tokens).toBe(expected)
    expect(matcher.partial).toBe(true)
  }
}
