package flat/parser/matchers

import flat/parser
import flat/parser/parsers
import flat/datastruct/HashMap
import flat/compiler/models/Token
import flat/log/Logger

import static flat/colorizer/Colorizer

data class extends TokenMatcher {
  static Logger log = Logger(NodeGroupTokenMatcher.class)

  NodeTokenPattern pattern

  var NodeTokenMatch[] childMatches = NodeTokenMatch[]
  var NodeGroupTokenMatch groupMatch
  var ParserBase[] currentParsers
  var NodeTokenMatcher currentMatcher
  var Bool addedCurrentMatch = false

  override public match(Token token, ParseContext context = null) -> NodeGroupTokenMatch {
    if (!currentParsers) {
      currentParsers = pattern.parsers
    }
    if (!currentMatcher) {
      currentMatcher = NodeTokenPattern(currentParsers).getMatcher()
    }

    return tokenMatches.add(doMatch(token, context))
  }

  doMatch(Token token, ParseContext context) -> NodeGroupTokenMatch => null {
    if (disqualified) return null
    log.traceFunc({"Matching token '#{green(token.value)}'"})

    tokens.add(token)

    if (let match = currentMatcher.match(token, context)) {
      log.traceFunc({"Successful match with current matcher"})
      if (currentMatcher.disqualified) {
        log.traceFunc({"Current matcher is disqualified. Returning match and switching to new current matcher"})

        if (addedCurrentMatch) {
          childMatches.replaceLast(match)
        } else {
          childMatches.add(match)
        }
      } else {
        log.traceFunc({"Current matcher is partial. Returning match and continuing"})
        childMatches.add(match)
        addedCurrentMatch = true
      }

      return groupMatch = NodeGroupTokenMatch(
        tokens: pattern.includeTokens ? tokens.copy() : Token[],
        label: pattern.label,
        childMatches: childMatches.copy()
      )
    } else if (!currentMatcher.partial) {
      if (groupMatch) {
        log.traceFunc({"Attempting match"})
        let tokensToMatch = tokens.skip(groupMatch.tokens.count)
        tokens = groupMatch.tokens.copy()
        currentMatcher.reset()
        addedCurrentMatch = false

        return tokensToMatch.map({
          return doMatch(_, context)
        }).last
      } else {
        log.traceFunc({"Did not match. Disqualified"})
        disqualified = true
      }
    } else {
      log.traceFunc({"Partial match. Continuing"})
    }
  }

  override public reset() {
    log.traceFunc({"Resetting matcher"})
    super.reset()

    pattern.parsers.forEach({ _.reset() })
    childMatches = NodeTokenMatch[]
    groupMatch = null
    currentParsers = pattern.parsers
    currentMatcher = null
    addedCurrentMatch = false
  }
}