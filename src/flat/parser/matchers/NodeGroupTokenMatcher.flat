package flat/parser/matchers

import flat/parser
import flat/parser/parsers
import flat/datastruct/HashMap
import flat/compiler/models/Token
import flat/log/Logger

import static flat/colorizer/Colorizer

data class extends TokenMatcher {
  static Logger log = Logger(NodeGroupTokenMatcher.class)

  NodeTokenPattern pattern

  var NodeTokenMatch[] childMatches = NodeTokenMatch[]
  var NodeGroupTokenMatch groupMatch
  var ParserBase[] currentParsers
  var NodeTokenMatcher currentMatcher
  var Bool addedCurrentMatch = false
  var Bool attemptingBacktrackMatch = false

  override public match(Token token, ParseContext context = null) -> NodeGroupTokenMatch {
    if (!currentParsers) {
      currentParsers = pattern.parsers
    }
    if (!currentMatcher) {
      currentMatcher = NodeTokenPattern(currentParsers).getMatcher()
    }

    return tokenMatches.add(doMatch(token, context))
  }

  doMatch(Token token, ParseContext context) -> NodeGroupTokenMatch => null {
    if (disqualified) return null
    log.traceFunc({"|
      Matching token '#{green(token.value)}':
        tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ")}]
      |"})

    tokens.add(token)

    if (let match = currentMatcher.match(token, context)) {
      log.traceFunc({"Successful match with current matcher"})
      if (currentMatcher.disqualified) {
        log.traceFunc({"Current matcher is disqualified. Returning match and switching to new current matcher"})
        currentParsers = pattern.parsers
        currentMatcher = NodeTokenPattern(currentParsers).getMatcher()
      } else {
        log.traceFunc({"Current matcher is partial. Returning match and continuing"})
      }

      if (addedCurrentMatch) {
        childMatches.replaceLast(match)
      } else {
        childMatches.add(match)
      }

      addedCurrentMatch = true

      if (groupMatch) {
        return groupMatch = groupMatch.copy(
          tokens: pattern.includeTokens ? tokens.copy() : Token[],
          childMatches: childMatches.copy()
        )
      } else {
        return groupMatch = NodeGroupTokenMatch(
          tokens: pattern.includeTokens ? tokens.copy() : Token[],
          label: pattern.label,
          childMatches: childMatches.copy()
        )
      }
    } else if (currentMatcher.partial) {
      log.traceFunc({"Partial match. Continuing"})
    } else if (groupMatch && !attemptingBacktrackMatch) {
      if (checkScopeStart(token)) {
        return handleScopeStart()
      } else if (checkScopeEnd(token)) {
        return handleScopeEnd()
      } else {
        let tokensToMatch = tokens.skip(groupMatch.tokens.count)
        tokens = groupMatch.tokens.copy()
        currentMatcher.reset()
        addedCurrentMatch = false
        if (tokensToMatch.isNotEmpty) {
          log.traceFunc({"|
            Attempting backtrack match:
              tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ")}]
              tokensToMatch: [#{tokensToMatch.map(t => "'" + green(t.value) + "'").join(", ")}]
              childMatches.last.tokens: [#{childMatches.last.tokens.map(t => "'" + green(t.value) + "'").join(", ")}]
            |"})

          attemptingBacktrackMatch = true
          let value = tokensToMatch.map({
            return doMatch(_, context)
          }).last
          attemptingBacktrackMatch = false

          return value
        } else {
          log.traceFunc({"No more tokens to match. Disqualified"})
          disqualified = true
        }
      }
    } else {
      log.traceFunc({"Did not match. Disqualified"})
      disqualified = true
    }
  }

  checkScopeStart(Token token) => false {
    match token.value {
      "{" => {
        log.traceFunc({"Encountered starting brace"})

        if (childMatches.last.parser.class.isOfType(ScopeableParser.class)) {
          log.traceFunc({"Successful scope push. parser: #{green(childMatches.last.parser.class.name)}"})

          return true
        } else {
          log.traceFunc({"Not a scope. Not pushing. parser: #{green(childMatches.last.parser.class.name)}"})
        }
      }
    }
  }

  handleScopeStart() -> NodeGroupTokenMatch {
    currentParsers = childMatches.last.parser.childParsers
    currentMatcher = NodeTokenPattern(currentParsers).getMatcher()
    addedCurrentMatch = false

    let childTokens = tokens.takeLast(1)

    childMatches.add(
      NodeTokenMatch(
        tokens: childTokens,
        childMatches: [
          NodeTokenMatchChild(
            tokens: childTokens,
            parser: LocalScopeParser()
          )
        ]
      )
    )

    return groupMatch = groupMatch.copy(
      tokens: pattern.includeTokens ? tokens.copy() : Token[],
      childMatches: childMatches.copy()
    )
  }

  checkScopeEnd(Token token) => false {
    match token.value {
      "}" => {
        log.traceFunc({"Encountered ending brace"})

        if (childMatches.last.parser.class.isOfType(ScopeableParser.class)) {
          log.traceFunc({"Successful scope pop. parser: #{green(childMatches.last.parser.class.name)}"})

          return true
        } else {
          log.traceFunc({"Not a scope. Not popping. parser: #{green(childMatches.last.parser.class.name)}"})
        }
      }
    }
  }

  handleScopeEnd() -> NodeGroupTokenMatch {
    currentParsers = pattern.parsers
    currentMatcher = NodeTokenPattern(currentParsers).getMatcher()
    addedCurrentMatch = false

    return groupMatch = groupMatch.copy(
      tokens: pattern.includeTokens ? tokens.copy() : Token[],
      childMatches: childMatches.copy()
    )
  }

  override public reset() {
    log.traceFunc({"Resetting matcher"})
    super.reset()

    pattern.parsers.forEach({ _.reset() })
    childMatches = NodeTokenMatch[]
    groupMatch = null
    currentParsers = pattern.parsers
    currentMatcher = null
    addedCurrentMatch = false
    attemptingBacktrackMatch = false
  }
}