package flat/parser

import flat/ast/FunctionCallNode
import flat/compiler/models/Token

class extends ParserBase {
  override ParserBase[] childParsers => Array():addAll([
    CommentParser(),
    DotAccessParser(),
    ColonAccessParser(),
    ArrayAccessParser()
  ])

  override lazy TokenMatcher matcher => pattern.getMatcher()

  override lazy TokenPattern pattern => GroupTokenPattern([
    SingleTokenPattern(Token.Type.IDENTIFIER, label: "name"),
    CaptureTokenPattern(
      label: "generic_arguments",
      start: Token(value: "<"),
      end: Token(value: ">"),
      optional: true
    ),
    GroupTokenPattern([
      SingleTokenPattern(Token.Type.SYMBOL, "("),
      GroupTokenPattern([
        NodeTokenPattern(argumentParsers, label: "arguments"),
        GroupTokenPattern([
          SingleTokenPattern(Token.Type.SYMBOL, ","),
          NodeTokenPattern(argumentParsers, label: "arguments")
        ], optional: true, repeat: true),
      ], optional: true),
      SingleTokenPattern(Token.Type.SYMBOL, ")")
    ])
  ])

  ParserBase[] argumentParsers => [
    AnnotationParser(),
    CommentParser(),
    FunctionCallParser(),
    IdentifierParser(),
    LiteralParser()
  ]

  override public checkStatementContinuation(ParseContext context, Token token) => token.type == Token.Type.SYMBOL

  override public generateNode(ParseContext context, TokenMatch match) -> FunctionCallNode {
    let name = match.getValue("name")

    let functionCallNode = FunctionCallNode(
      name: name
    )

    let functionCallContext = context.copy(
      parentStack: context.parentStack.copy():push(functionCallNode)
    )

    let arguments = match.getMatches<NodeTokenMatch>("arguments")
      .map(m => m.parser.generateNode(functionCallContext, m))

    functionCallNode.children.addAll(arguments)

    return functionCallNode
  }
}