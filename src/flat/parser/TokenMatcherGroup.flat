package flat/parser

import flat/datastruct/HashMap
import flat/datastruct/list/Queue
import flat/compiler/models/Token
import flat/log/Logger

data class extends TokenMatcher {
  let static Logger log = Logger(TokenMatcherGroup.class)

  override let lazy Int requiredTokenCount => matchers.sum({ _.requiredTokenCount })

  public construct(
    visible Array<TokenMatcher> matchers,
    this Bool optional = false,
    this Bool repeat = false,
    this Bool greedy = true
  ) {}

  override public matches(
    var Token[] tokens,
    Bool requireAllTokensConsumed = true
  ) -> TokenMatch => null {
    if (tokens.isEmpty) return null

    tokens = tokens.toArray()

    let outputLabels = HashMap<String, Array<String>>()
    let matchedTokens = Token[]
    let iterator = matchers.iterator

    while (iterator.hasNext) {
      let matcher = iterator.stepNext

      if (matcher.optional && !matcher.greedy) {
        if (iterator.hasNext && iterator.next.matches(tokens, false)) {
          continue
        }
      }

      var match = matcher.matches(tokens, false)

      if (!match) {
        if (matchedTokens.isNotEmpty) {
          return TokenMatch(matchedTokens, outputLabels, partial: true)
        }
        break
      }

      while (true) {
        match.tokens.forEach({ tokens.shift() })

        matchedTokens.addAll(match.tokens)
        match.values.forEach((entry) => {
          outputLabels.getOrDefault(entry.key, { Array() }).addAll(entry.value)
        })

        if (!matcher.repeat || tokens.isEmpty) {
          break
        }

        match = matcher.matches(tokens, false)
      }
    }

    if (!requireAllTokensConsumed || tokens.isEmpty) {
      return TokenMatch(matchedTokens, outputLabels, partial: false)
    }
  }
}