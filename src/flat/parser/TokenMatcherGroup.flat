package flat/parser

import flat/datastruct/HashMap
import flat/datastruct/list/Queue
import flat/compiler/models/Token
import flat/log/Logger

data class extends TokenMatcher {
  let static Logger log = Logger(TokenMatcherGroup.class)

  public construct(
    visible Array<TokenMatcher> matchers,
    this Bool optional = false,
    this Bool repeat = false,
    this Bool greedy = true
  ) {}

  override public matches(var Token[] tokens, Bool requireAllTokensConsumed = true) -> TokenMatch => null {
    tokens = tokens.toArray()

    let outputLabels = HashMap<String, Array<String>>()
    let matchedTokens = Token[]

    for (i in 0..matchers.count) {
      let matcher = matchers[i]

      if (matcher.optional && !matcher.greedy) {
        if (matchers.count > i + 1 && matchers[i + 1].matches(tokens, false)) {
          continue
        }
      }
      while (let match = matcher.matches(tokens, false)) {
        match.tokens.forEach({ tokens.shift() })

        matchedTokens.addAll(match.tokens)
        match.values.forEach((entry) => {
          outputLabels.getOrDefault(entry.key, { Array() }).addAll(entry.value)
        })

        if (!matcher.repeat || tokens.isEmpty) {
          break
        }
      }
    }

    if (!requireAllTokensConsumed || tokens.isEmpty) {
      return TokenMatch(matchedTokens, outputLabels)
    }
  }
}