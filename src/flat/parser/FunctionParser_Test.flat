package flat/parser

import flat/datastruct/HashMap
import flat/parser/Parser
import flat/ast/FileNode
import flat/ast/FunctionNode
import flat/compiler/models/Token
import flat/io/File

testable class {
  async test `can parse function without parameters or type`() {
    let result = FunctionParser().pattern.matches([
      Token(value: "test", type: Token.Type.IDENTIFIER),
      Token(value: "(", type: Token.Type.SYMBOL),
      Token(value: ")", type: Token.Type.SYMBOL)
    ])

    let expected = TokenMatch(
      tokens: [
        Token(value: "test", type: Token.Type.IDENTIFIER),
        Token(value: "(", type: Token.Type.SYMBOL),
        Token(value: ")", type: Token.Type.SYMBOL)
      ],
      partial: false
    )

    expect(result).toBe(expected)
  }

  async test `can parse function with single parameter, but no type`() {
    let result = FunctionParser().pattern.matches([
      Token(value: "test", type: Token.Type.IDENTIFIER),
      Token(value: "(", type: Token.Type.SYMBOL),
      Token(value: "Test", type: Token.Type.IDENTIFIER),
      Token(value: "value", type: Token.Type.IDENTIFIER),
      Token(value: ")", type: Token.Type.SYMBOL)
    ])

    let expected = TokenMatch(
      tokens: [
        Token(value: "test", type: Token.Type.IDENTIFIER),
        Token(value: "(", type: Token.Type.SYMBOL),
        Token(value: "Test", type: Token.Type.IDENTIFIER),
        Token(value: "value", type: Token.Type.IDENTIFIER),
        Token(value: ")", type: Token.Type.SYMBOL)
      ],
      partial: false
    )

    expect(result).toBe(expected)
  }

  async test `can parse function with multiple parameters, but no type`() {
    let result = FunctionParser().pattern.matches([
      Token(value: "test", type: Token.Type.IDENTIFIER),
      Token(value: "(", type: Token.Type.SYMBOL),
      Token(value: "Test", type: Token.Type.IDENTIFIER),
      Token(value: "value", type: Token.Type.IDENTIFIER),
      Token(value: ",", type: Token.Type.SYMBOL),
      Token(value: "Test", type: Token.Type.IDENTIFIER),
      Token(value: "value2", type: Token.Type.IDENTIFIER),
      Token(value: ")", type: Token.Type.SYMBOL)
    ])

    let expected = TokenMatch(
      tokens: [
        Token(value: "test", type: Token.Type.IDENTIFIER),
        Token(value: "(", type: Token.Type.SYMBOL),
        Token(value: "Test", type: Token.Type.IDENTIFIER),
        Token(value: "value", type: Token.Type.IDENTIFIER),
        Token(value: ",", type: Token.Type.SYMBOL),
        Token(value: "Test", type: Token.Type.IDENTIFIER),
        Token(value: "value2", type: Token.Type.IDENTIFIER),
        Token(value: ")", type: Token.Type.SYMBOL)
      ],
      partial: false
    )

    expect(result).toBe(expected)
  }

  async test `can parse function with multiple parameters and a basic type`() {
    let result = FunctionParser().pattern.matches([
      Token(value: "test", type: Token.Type.IDENTIFIER),
      Token(value: "(", type: Token.Type.SYMBOL),
      Token(value: "Test", type: Token.Type.IDENTIFIER),
      Token(value: "value", type: Token.Type.IDENTIFIER),
      Token(value: ",", type: Token.Type.SYMBOL),
      Token(value: "Test", type: Token.Type.IDENTIFIER),
      Token(value: "value2", type: Token.Type.IDENTIFIER),
      Token(value: ")", type: Token.Type.SYMBOL),
      Token(value: "->", type: Token.Type.SYMBOL),
      Token(value: "Object", type: Token.Type.IDENTIFIER)
    ])

    let expected = TokenMatch(
      tokens: [
        Token(value: "test", type: Token.Type.IDENTIFIER),
        Token(value: "(", type: Token.Type.SYMBOL),
        Token(value: "Test", type: Token.Type.IDENTIFIER),
        Token(value: "value", type: Token.Type.IDENTIFIER),
        Token(value: ",", type: Token.Type.SYMBOL),
        Token(value: "Test", type: Token.Type.IDENTIFIER),
        Token(value: "value2", type: Token.Type.IDENTIFIER),
        Token(value: ")", type: Token.Type.SYMBOL),
        Token(value: "->", type: Token.Type.SYMBOL),
        Token(value: "Object", type: Token.Type.IDENTIFIER)
      ],
      partial: false
    )

    expect(result).toBe(expected)
  }

  async test `can parse function with multiple parameters and a type with array single brackets`() {
    let result = FunctionParser().pattern.matches([
      Token(value: "test", type: Token.Type.IDENTIFIER),
      Token(value: "(", type: Token.Type.SYMBOL),
      Token(value: "Test", type: Token.Type.IDENTIFIER),
      Token(value: "value", type: Token.Type.IDENTIFIER),
      Token(value: ",", type: Token.Type.SYMBOL),
      Token(value: "Test", type: Token.Type.IDENTIFIER),
      Token(value: "value2", type: Token.Type.IDENTIFIER),
      Token(value: ")", type: Token.Type.SYMBOL),
      Token(value: "->", type: Token.Type.SYMBOL),
      Token(value: "Object", type: Token.Type.IDENTIFIER),
      Token(value: "[", type: Token.Type.SYMBOL),
      Token(value: "]", type: Token.Type.SYMBOL)
    ])

    let expected = TokenMatch(
      tokens: [
        Token(value: "test", type: Token.Type.IDENTIFIER),
        Token(value: "(", type: Token.Type.SYMBOL),
        Token(value: "Test", type: Token.Type.IDENTIFIER),
        Token(value: "value", type: Token.Type.IDENTIFIER),
        Token(value: ",", type: Token.Type.SYMBOL),
        Token(value: "Test", type: Token.Type.IDENTIFIER),
        Token(value: "value2", type: Token.Type.IDENTIFIER),
        Token(value: ")", type: Token.Type.SYMBOL),
        Token(value: "->", type: Token.Type.SYMBOL),
        Token(value: "Object", type: Token.Type.IDENTIFIER),
        Token(value: "[", type: Token.Type.SYMBOL),
        Token(value: "]", type: Token.Type.SYMBOL)
      ],
      partial: false
    )

    expect(result).toBe(expected)
  }

  async test `can parse function with multiple parameters and a type with array multiple brackets`() {
    let result = FunctionParser().pattern.matches([
      Token(value: "test", type: Token.Type.IDENTIFIER),
      Token(value: "(", type: Token.Type.SYMBOL),
      Token(value: "Test", type: Token.Type.IDENTIFIER),
      Token(value: "value", type: Token.Type.IDENTIFIER),
      Token(value: ",", type: Token.Type.SYMBOL),
      Token(value: "Test", type: Token.Type.IDENTIFIER),
      Token(value: "value2", type: Token.Type.IDENTIFIER),
      Token(value: ")", type: Token.Type.SYMBOL),
      Token(value: "->", type: Token.Type.SYMBOL),
      Token(value: "Object", type: Token.Type.IDENTIFIER),
      Token(value: "[", type: Token.Type.SYMBOL),
      Token(value: "]", type: Token.Type.SYMBOL),
      Token(value: "[", type: Token.Type.SYMBOL),
      Token(value: "]", type: Token.Type.SYMBOL)
    ])

    let expected = TokenMatch(
      tokens: [
        Token(value: "test", type: Token.Type.IDENTIFIER),
        Token(value: "(", type: Token.Type.SYMBOL),
        Token(value: "Test", type: Token.Type.IDENTIFIER),
        Token(value: "value", type: Token.Type.IDENTIFIER),
        Token(value: ",", type: Token.Type.SYMBOL),
        Token(value: "Test", type: Token.Type.IDENTIFIER),
        Token(value: "value2", type: Token.Type.IDENTIFIER),
        Token(value: ")", type: Token.Type.SYMBOL),
        Token(value: "->", type: Token.Type.SYMBOL),
        Token(value: "Object", type: Token.Type.IDENTIFIER),
        Token(value: "[", type: Token.Type.SYMBOL),
        Token(value: "]", type: Token.Type.SYMBOL),
        Token(value: "[", type: Token.Type.SYMBOL),
        Token(value: "]", type: Token.Type.SYMBOL)
      ],
      partial: false
    )

    expect(result).toBe(expected)
  }

  async test `can parse function with no parameters and a type with array multiple brackets`() {
    let result = FunctionParser().pattern.matches([
      Token(value: "test", type: Token.Type.IDENTIFIER),
      Token(value: "(", type: Token.Type.SYMBOL),
      Token(value: ")", type: Token.Type.SYMBOL),
      Token(value: "->", type: Token.Type.SYMBOL),
      Token(value: "Object", type: Token.Type.IDENTIFIER),
      Token(value: "[", type: Token.Type.SYMBOL),
      Token(value: "]", type: Token.Type.SYMBOL),
      Token(value: "[", type: Token.Type.SYMBOL),
      Token(value: "]", type: Token.Type.SYMBOL)
    ])

    let expected = TokenMatch(
      tokens: [
        Token(value: "test", type: Token.Type.IDENTIFIER),
        Token(value: "(", type: Token.Type.SYMBOL),
        Token(value: ")", type: Token.Type.SYMBOL),
        Token(value: "->", type: Token.Type.SYMBOL),
        Token(value: "Object", type: Token.Type.IDENTIFIER),
        Token(value: "[", type: Token.Type.SYMBOL),
        Token(value: "]", type: Token.Type.SYMBOL),
        Token(value: "[", type: Token.Type.SYMBOL),
        Token(value: "]", type: Token.Type.SYMBOL)
      ],
      partial: false
    )

    expect(result).toBe(expected)
  }

  async test `can parse function with expression return`() {
    let result = FunctionParser().pattern.matches([
      Token(value: "test", type: Token.Type.IDENTIFIER),
      Token(value: "(", type: Token.Type.SYMBOL),
      Token(value: ")", type: Token.Type.SYMBOL),
      Token(value: "=>", type: Token.Type.SYMBOL)
    ])

    let expected = TokenMatch(
      tokens: [
        Token(value: "test", type: Token.Type.IDENTIFIER),
        Token(value: "(", type: Token.Type.SYMBOL),
        Token(value: ")", type: Token.Type.SYMBOL),
        Token(value: "=>", type: Token.Type.SYMBOL)
      ],
      partial: false
    )

    expect(result).toBe(expected)
  }
}
