package flat/parser

import flat/datastruct/HashMap
import flat/compiler/models/Token
import flat/log/Logger

import static flat/colorizer/Colorizer

data class extends TokenMatcher {
  static Logger log = Logger(NodeTokenMatcher.class)

  NodeTokenPattern pattern

  override public match(Token token) -> NodeTokenMatch {
    return tokenMatches.add(doMatch(token))
  }

  doMatch(Token token) -> NodeTokenMatch {
    if (disqualified) return null
    log.traceFunc({"Matching token '#{green(token.value)}'"})

    var ParserBase matchParser
    let TokenMatch[] matches = Array()

    for (parser in pattern.parsers) {
      if (let match = parser.match(token)) {
        matches.add(match)
        if (!matchParser) {
          matchParser = parser
        }
      }
    }

    if (pattern.parsers.all(p => !p.matcher.complete && p.matcher.disqualified)) {
      log.trace("All matchers are disqualified. Disqualified")
      disqualified = true
      return null
    }

    tokens.add(token)

    valid = true

    if (matches.isNotEmpty) {
      complete = matchParser.matcher.complete
      log.trace("Matches: #{matches.map(m => green(m.class.name))} parser: #{matchParser.class.name}")
    } else {
      log.trace("Matches are empty")
    }

    return NodeTokenMatch(
      tokens: tokens.copy(),
      label: pattern.label,
      parser: matchParser
    )
  }

  override public reset() {
    super.reset()

    pattern.parsers.forEach({ _.matcher.reset() })
  }
}