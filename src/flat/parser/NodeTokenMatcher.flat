package flat/parser

import flat/datastruct/HashMap
import flat/compiler/models/Token
import flat/log/Logger

import static flat/colorizer/Colorizer

data class extends TokenMatcher {
  static Logger log = Logger(NodeTokenMatcher.class)

  NodeTokenPattern pattern

  var NodeTokenMatch lastMatch

  override public match(Token token, ParseContext context = null) -> NodeTokenMatch {
    return tokenMatches.add(doMatch(token))
  }

  doMatch(Token token) -> NodeTokenMatch {
    if (disqualified) return null
    log.traceFunc({"Matching token '#{green(token.value)}'"})

    var ParserBase matchParser
    let TokenMatch[] matches = Array()

    for (parser in pattern.parsers) {
      log.traceFunc({"Matching token '#{green(token.value)}' against parser: #{green(parser.class.name)}"})
      if (let match = parser.match(token)) {
        log.traceFunc({"Matched token '#{green(token.value)}'"})
        matches.add(match)
        if (!matchParser) {
          matchParser = parser
        }
      } else if (parser.matcher.partial) {
        log.traceFunc({"Partial match for token '#{green(token.value)}'"})
      } else {
        log.traceFunc({"Didn't match token '#{green(token.value)}'"})
      }
    }

    if (pattern.parsers.all(p => !p.matcher.complete && p.matcher.disqualified)) {
      log.traceFunc({"All matchers are disqualified. Disqualified"})
      disqualified = true
      return null
    }

    tokens.add(token)

    valid = true

    let remainingPartialMatches = pattern.parsers.any(p => p != matchParser && p.matcher.partial)

    if (matches.isNotEmpty) {
      log.traceFunc({"Matches: [#{matches.map(m => green(m.class.name)).join(", ")}] parser: #{matchParser.class.name}"})
      complete = matchParser.matcher.complete && pattern.parsers.none({ _.matcher.partial })
      lastMatch = NodeTokenMatch(
        tokens: pattern.includeTokens ? tokens.copy() : Token[],
        label: pattern.label,
        parser: matchParser
      )
      if (remainingPartialMatches) {
        log.traceFunc({"Contains partial matches. Continuing"})
        return null
      } else {
        log.traceFunc({"No more partial matches. Returning last match"})
      }
    } else {
      log.traceFunc({"Matches are empty"})
      if (lastMatch) {
        log.traceFunc({"Has last match"})
        if (remainingPartialMatches) {
          log.traceFunc({"Contains partial matches. Continuing"})
          return null
        } else {
          log.traceFunc({"No more partial matches. Disqualified. Returning last match"})
          complete = lastMatch.parser.matcher.complete
          disqualified = true
        }
      } else {
        log.traceFunc({"Does not have last match"})
        if (remainingPartialMatches) {
          log.traceFunc({"Contains partial matches. Continuing"})
          return null
        } else {
          log.traceFunc({"Never matched. Disqualified"})
          disqualified = true
          return null
        }
      }
    }

    return lastMatch
  }

  override public reset() {
    log.traceFunc({"Resetting matcher"})
    super.reset()

    pattern.parsers.forEach({ _.matcher.reset() })
  }
}