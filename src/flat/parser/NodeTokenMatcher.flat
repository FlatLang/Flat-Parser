package flat/parser

import flat/datastruct/HashMap
import flat/compiler/models/Token
import flat/log/Logger

import static flat/colorizer/Colorizer

data class extends TokenMatcher {
  static Logger log = Logger(NodeTokenMatcher.class)

  NodeTokenPattern pattern

  var ParserBase lastMatch

  override public match(Token token) -> NodeTokenMatch {
    return tokenMatches.add(doMatch(token))
  }

  doMatch(Token token) -> NodeTokenMatch {
    if (disqualified) return null
    log.traceFunc({"Matching token '#{green(token.value)}'"})

    var ParserBase matchParser
    let TokenMatch[] matches = Array()

    for (parser in pattern.parsers) {
      if (let match = parser.match(token)) {
        matches.add(match)
        if (!matchParser) {
          matchParser = parser
        }
      }
    }

    if (pattern.parsers.all(p => !p.matcher.complete && p.matcher.disqualified)) {
      log.traceFunc({"All matchers are disqualified. Disqualified"})
      disqualified = true
      return null
    }

    tokens.add(token)

    valid = true

    if (matches.isNotEmpty) {
      log.traceFunc({"Matches: #{matches.map(m => green(m.class.name))} parser: #{matchParser.class.name}"})
      complete = matchParser.matcher.complete && pattern.parsers.none({ _.matcher.partial })
      lastMatch = matchParser
    } else {
      log.traceFunc({"Matches are empty"})
      let partialMatch = pattern.parsers.any({ _.matcher.partial })
      if (lastMatch) {
        log.traceFunc({"Has last match"})
        if (partialMatch) {
          log.traceFunc({"Contains partial matches. Continuing"})
          return null
        } else {
          log.traceFunc({"No more partial matches. Disqualified"})
          complete = lastMatch.matcher.complete
          disqualified = true
          return null
        }
      } else {
        log.traceFunc({"Does not have last match"})
        if (partialMatch) {
          log.traceFunc({"Contains partial matches. Continuing"})
          return null
        } else {
          log.traceFunc({"Never matched. Disqualified"})
          disqualified = true
          return null
        }
      }
    }

    return NodeTokenMatch(
      tokens: tokens.copy(),
      label: pattern.label,
      parser: matchParser
    )
  }

  override public reset() {
    super.reset()

    pattern.parsers.forEach({ _.matcher.reset() })
  }
}