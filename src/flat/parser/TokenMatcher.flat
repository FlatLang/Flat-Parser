package flat/parser

import flat/datastruct/HashMap
import flat/compiler/models/Token
import flat/log/Logger

data class {
  static Logger log = Logger(TokenMatcher.class)

  visible TokenPattern pattern

  visible Bool partial => tokens.isNotEmpty && !disqualified

  Token[] _tokens = Token[]
  visible Token[] tokens <=> _tokens

  var Bool _disqualified = false
  visible var Bool disqualified <=> _disqualified

  var Bool _valid = false
  visible var Bool valid <=> _valid

  var Bool _complete = false
  visible var Bool complete <=> _complete

  public matchAll(Token[] tokens) -> TokenMatch[] => tokens.map({ this.match(_) })

  public match(Token token) -> TokenMatch {
    if (disqualified) return null
    if (!pattern.repeat && tokens.isNotEmpty) {
      disqualified = true
      return null
    }
    if (pattern.tokenType != token.type) {
      disqualified = true
      return null
    }
    if (pattern.value && pattern.value != token.value) {
      disqualified = true
      return null
    }
    if (pattern.values && pattern.values.none({ _ == token.value})) {
      disqualified = true
      return null
    }

    tokens.add(token)

    let outputLabels = HashMap<String, Array<String>>()

    if (pattern.label) {
      outputLabels.getOrDefault(pattern.label, { Array() }).addAll(tokens.map({ _.value }))
    }
    if (!pattern.repeat) {
      disqualified = true
    }
    valid = true
    complete = true

    return TokenMatch(tokens.copy(), outputLabels.copy())
  }
}