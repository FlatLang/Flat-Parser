package flat/parser

import flat/datastruct/list/Stack
import flat/ast/Node
import flat/ast/AnnotationNode
import flat/ast/FileNode
import flat/ast/ClassNode
import flat/ast/FunctionNode
import flat/ast/ScopeNode
import flat/ast/ClassScopeNode
import flat/ast/FunctionScopeNode
import flat/ast/FileScopeNode
import flat/compiler/models/Token
import flat/io/File
import flat/log/Logger
import flat/stream/Stream

class {
  let static Logger log = Logger(ParseEngine.class)

  visible var EngineContext context = EngineContext()
  Stack<EngineContext> snapshots = Stack()

  public construct(
    private FileNode fileNode,
    private Stream stream
  ) {
    context.pushScope(FileParser(), fileNode)
    context.pushScope(FileScopeParser(), FileScopeNode())
  }

  public containsPartialMatches() =>
    context.currentParsers.any(p => p.matcher.partial || p.matcher.tokenMatches.last != null)

  public getPartialMatches() =>
    context.currentParsers.filter(p => p.matcher.partial || p.matcher.tokenMatches.last != null)

  public containsCompletedMatches() =>
    context.currentParsers.any({ _.lastMatch != null })

  public getCompletedMatches() =>
    context.currentParsers.filter({ _.lastMatch != null })

  public getBestMatch(ParserBase[] parsers) -> ParserBase {
    let maxTokenCount = parsers.max({ _.lastMatch.tokens.count })

    if (parsers.howMany({ _.lastMatch.tokens.count == maxTokenCount }) > 1) {
      log.debugFunc({"Multiple parsers available, choosing first: [#{parsers.filter(p => p.lastMatch.tokens.count == maxTokenCount).map(p => p.class.name).join(", ")}]"})
    }

    return parsers.firstWhere({ _.lastMatch.tokens.count == maxTokenCount })
  }

  public consume(Token token) {
    match token.type {
      Token.Type.COMMENT =>
      Token.Type.WS => return
      Token.Type.SYMBOL => {
        match token.value {
          "}" => {
            ParseEngine.log.debugFunc({"Encountered closing brace"})
            tryGenerateNodeForRemainingTokens()
            context.popScope(token)
            return
          }
        }
      }
    }

    if (context.tokens.isEmpty) {
      checkStatementEnd(token)
    }

    context.tokens.add(token)

    matchToken(token)
  }

  public matchToken(Token token) {
    ParseEngine.log.debugFunc({"Matching token: '#{token.value}' (tokens: [#{context.tokens.map(t => "'" + t.value + "'").join(", ")}])"})
    ParseEngine.log.debugFunc({"Parsers: [#{context.currentParsers.map(p => p.class.name).join(", ")}]"})

    context.currentParsers.forEach((parser) => {
      if (let match = parser.match(token)) {
        ParseEngine.log.debugFunc({"Matched: #{parser.class.name}"})
      } else if (parser.matcher.partial) {
        ParseEngine.log.debugFunc({"Partial match: #{parser.class.name}"})
      }
    })

    checkMatches()
  }

  checkMatches() {
    let containsPartialMatches = containsPartialMatches()

    if (!containsPartialMatches()) {
      ParseEngine.log.debugFunc({"No partial matches"})
      if (containsCompletedMatches()) {
        ParseEngine.log.debugFunc({"Has completed matches"})
        ParseEngine.log.traceFunc({"Completed matches:\n  #{getCompletedMatches().map(m => m.pattern.toPatternString()).join("\n  ")}"})
        let parser = getBestMatch(getCompletedMatches())
        let node = generateNode(parser)
        context.updateScopeForNode(parser, node)
        clearTokensAfterParse(parser)
      } else {
        ParseEngine.log.debugFunc({"No completed matches"})
        invalidTokens()
      }
    } else {
      ParseEngine.log.debugFunc({"Has partial matches"})
      ParseEngine.log.traceFunc({"Partial matches:\n  #{getPartialMatches().map(m => m.pattern.toPatternString()).join("\n  ")}"})

      if (containsCompletedMatches()) {
        ParseEngine.log.debugFunc({"Has completed matches"})
        ParseEngine.log.traceFunc({"Completed matches:\n  #{getCompletedMatches().map(m => m.pattern.toPatternString()).join("\n  ")}"})
        let parser = getBestMatch(getCompletedMatches())
        ParseEngine.log.debugFunc({"Matched parser: #{parser.class.name}"})

        if (parser.class.isOfType(AnnotationParser.class)) {
          ParseEngine.log.debugFunc({"Generating annotation"})
          if (let annotation = generateAnnotation(parser)) {
            context.parseContext.annotations.add(annotation)
            clearTokensAfterParse(parser)
          }
        } else {
          ParseEngine.log.debugFunc({"Not an annotation. Skipping"})
        }
      } else {
        ParseEngine.log.debugFunc({"No completed matches"})
      }
    }
  }

  public reset() {
    ParseEngine.log.debugFunc({"Resetting parsers"})
    context.currentParsers.forEach({ _.reset() })
  }

  public clearTokensAfterParse(ParserBase parser) {
    ParseEngine.log.debugFunc({"Removing tokens from last parse: [#{parser.lastMatch.tokens.map(t => "'" + t.value + "'").join(", ")}]"})
    parser.lastMatch.tokens.forEach({
      if (context.tokens.isNotEmpty) {
        context.tokens.shift()
      }
    })

    if (context.tokens.isNotEmpty) {
      ParseEngine.log.debugFunc({"Checking statement end for token '#{context.tokens.first.value}' (Parser: #{context.currentParser.class.name})"})
      if (isStatementEnd(context.tokens.first)) {
        context.resetCurrentScope()
      } else {
        ParseEngine.log.debugFunc({"Not statement end"})
      }
    } else {
      ParseEngine.log.debugFunc({"No tokens left after clearing tokens"})
    }

    reset()

    context.tokens.forEach({ matchToken(_) })
  }

  public generateNode(ParserBase parser) -> Node {
    ParseEngine.log.debugFunc({"Generating node for parser: #{parser.class.name}"})
    let node = parser.generateNode(context.parseContext, parser.lastMatch)

    if (!node) {
      throw Exception("Failed to parse node for parser: #{parser}")
    }

    stream.emit("data", node)$

    parseChildNodes(parser, node)

    return node
  }

  public parseChildNodes(ParserBase parser, Node parent) {
    if (let requests = parser.getChildParseRequests(context.parseContext, parser.lastMatch).requests) {
      requests.forEach((request) => {
        snapshopEngineContext()

        context.setChildParsers(context.currentParser, context.currentNode, request.parsers)
        context.tokens = Token[]

        ParseEngine.log.debugFunc({"Parsing child node with tokens: [#{request.tokens.map(t => "'" + t.value + "'").join(", ")}]"})
        request.tokens.forEach({ consume(_) })

        if (context.tokens.isNotEmpty) {
          tryGenerateNodeForRemainingTokens()
        }

        restoreSnapshopEngineContext()
      })
    }
  }

  public generateAnnotation(AnnotationParser parser) -> AnnotationNode {
    ParseEngine.log.debugFunc({"Generating annotation for parser: #{parser.class.name}"})
    let node = parser.generateNode(context.parseContext, parser.lastMatch)

    if (!node) {
      throw Exception("Failed to parse annotation for parser: #{parser}")
    }

    return node
  }

  public snapshopEngineContext() {
    ParseEngine.log.debugFunc({"Snapshotting engine context"})
    snapshots.push(context)
    context = context.copy(
      parentStack: Stack(context.parentStack.toArray().map({ _.copy() })),
      parserStack: Stack(context.parserStack.toArray().map({ _.copy() })),
      parsersStack: Stack(context.parsersStack.toArray().map({ _.map({ _.copy() }) })),
      currentParsers: context.currentParsers.map({ _.copy() }),
      tokens: context.tokens.copy(),
      parseContext: context.parseContext.copy(),
      currentNode: context.currentNode.copy(),
      currentParser: context.currentParser.copy()
    )
  }

  public restoreSnapshopEngineContext() {
    ParseEngine.log.debugFunc({"Restoring snapshotted engine context"})
    context = snapshots.pop()
  }

  public tryGenerateNodeForRemainingTokens() {
    if (context.tokens.isEmpty) return

    if (!containsCompletedMatches()) {
      ParseEngine.log.debugFunc({"No completed matches. Not generating node"})
      invalidTokens()
      return
    }

    let parser = getBestMatch(getCompletedMatches())
    let node = generateNode(parser)
    context.updateScopeForNode(parser, node)
    clearTokensAfterParse(parser)
  }

  public checkStatementEnd(Token token) {
    if (isStatementEnd(token)) {
      ParseEngine.log.debugFunc({"Reached end of statement (token: '#{token.value}', tokens: [#{context.tokens.map(t => "'" + t.value + "'").join(", ")}]). Generating node"})
      tryGenerateNodeForRemainingTokens()
    } else {
      ParseEngine.log.debugFunc({"Not end of statement"})
    }
  }

  public isStatementEnd(Token token) => false {
    return !context.currentParser.checkStatementContinuation(context.parseContext, token)
  }

  public invalidTokens() {
    invalidTokensError(context.tokens)
    context.resetCurrentScope()
    reset()
    context.tokens = Token[]
  }

  public invalidTokensError(Token[] tokens) {
    ParseEngine.log.debugFunc({"Could not parse tokens [#{tokens.map(t => "'" + t.value + "'").join(", ")}]. Resetting tokens. Parser #{context.currentParser.class.name}"})
    if (tokens.isNotEmpty && tokens.first.location) {
      let location = if (tokens.count == 1 && tokens.first.value.count == 1) {
        "#{tokens.first.location.lineNumber}:#{tokens.first.location.column}"
      } else {
        "#{tokens.first.location.lineNumber}:#{tokens.first.location.column}-#{tokens.last.endLineNumber}:#{tokens.last.endColumn}"
      }

      ParseEngine.log.errorFunc({"Could not parse tokens [#{tokens.map(t => "'" + t.value + "'").join(", ")}] at #{location}"})
    }
  }
}