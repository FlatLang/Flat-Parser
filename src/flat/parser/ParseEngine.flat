package flat/parser

import flat/datastruct/list/Stack
import flat/ast/Node
import flat/ast/AnnotationNode
import flat/ast/FileNode
import flat/ast/ClassNode
import flat/ast/FunctionNode
import flat/ast/ScopeNode
import flat/ast/ClassScopeNode
import flat/ast/FunctionScopeNode
import flat/ast/FileScopeNode
import flat/compiler/models/Token
import flat/io/File
import flat/log/Logger
import flat/stream/Stream

class {
  let static Logger log = Logger(ParseEngine.class)

  visible Stack<Node> parentStack = Stack()
  Stack<ParserBase> parserStack = Stack()
  Stack<Array<ParserBase>> parsersStack = Stack()

  let AnnotationParser annotationParser = AnnotationParser()

  var Token[] tokens = Token[]
  var ParseContext context = ParseContext()

  var Node currentNode
  var ParserBase currentParser
  var ParserBase[] currentParsers = ParserBase[]

  public construct(
    private FileNode fileNode,
    private Stream stream
  ) {
    pushScope(FileParser(), fileNode)
    pushScope(FileScopeParser(), FileScopeNode())
  }

  public containsPartialMatches() =>
    currentParsers.any(p => p.matcher.partial || p.matcher.tokenMatches.last != null)

  public getPartialMatches() =>
    currentParsers.filter(p => p.matcher.partial || p.matcher.tokenMatches.last != null)

  public containsCompletedMatches() =>
    currentParsers.any({ _.lastMatch != null })

  public getCompletedMatches() =>
    currentParsers.filter({ _.lastMatch != null })

  public getBestMatch(ParserBase[] parsers) -> ParserBase {
    let maxTokenCount = parsers.max({ _.lastMatch.tokens.count })

    if (parsers.howMany({ _.lastMatch.tokens.count == maxTokenCount }) > 1) {
      log.debugFunc({"Multiple parsers available, choosing first: [#{parsers.filter(p => p.lastMatch.tokens.count == maxTokenCount).map(p => p.class.name).join(", ")}]"})
    }

    return parsers.firstWhere({ _.lastMatch.tokens.count == maxTokenCount })
  }

  public consume(Token token) {
    match token.type {
      Token.Type.WS => return
      Token.Type.SYMBOL => {
        match token.value {
          "}" => {
            ParseEngine.log.debugFunc({"Encountered closing brace"})
            tryGenerateNodeForRemainingTokens()
            popScope(token)
            return
          }
        }
      }
    }

    checkStatementEnd(token)

    tokens.add(token)

    matchToken(token)
  }

  public matchToken(Token token) {
    ParseEngine.log.debugFunc({"Matching token: '#{token.value}' (tokens: [#{tokens.map(t => "'" + t.value + "'").join(", ")}])"})
    ParseEngine.log.debugFunc({"Parsers: [#{currentParsers.map(p => p.class.name).join(", ")}]"})

    currentParsers.forEach((parser) => {
      if (let match = parser.match(token)) {
        ParseEngine.log.debugFunc({"Matched: #{parser.class.name}"})
      } else if (parser.matcher.partial) {
        ParseEngine.log.debugFunc({"Partial match: #{parser.class.name}"})
      }
    })

    let containsPartialMatches = containsPartialMatches()

    if (!containsPartialMatches()) {
      ParseEngine.log.debugFunc({"No partial matches"})
      if (containsCompletedMatches()) {
        ParseEngine.log.debugFunc({"Has completed matches"})
        ParseEngine.log.traceFunc({"Completed matches:\n  #{getCompletedMatches().map(m => m.pattern.toPatternString()).join("\n  ")}"})
        let parser = getBestMatch(getCompletedMatches())
        let node = generateNode(parser)
        updateScopeForNode(parser, node)
        clearTokensAfterParse(parser)
      } else {
        ParseEngine.log.debugFunc({"No completed matches"})
        invalidTokens()
      }
    } else {
      ParseEngine.log.debugFunc({"Has partial matches"})
      ParseEngine.log.traceFunc({"Partial matches:\n  #{getPartialMatches().map(m => m.pattern.toPatternString()).join("\n  ")}"})

      if (containsCompletedMatches()) {
        ParseEngine.log.debugFunc({"Has completed matches"})
        ParseEngine.log.traceFunc({"Completed matches:\n  #{getCompletedMatches().map(m => m.pattern.toPatternString()).join("\n  ")}"})
        let parser = getBestMatch(getCompletedMatches())
        ParseEngine.log.debugFunc({"Matched parser: #{parser.class.name}"})

        if (parser.class.isOfType(AnnotationParser.class)) {
          ParseEngine.log.debugFunc({"Generating annotation"})
          if (let annotation = generateAnnotation(parser)) {
            context.annotations.add(annotation)
            clearTokensAfterParse(parser)
          }
        } else {
          ParseEngine.log.debugFunc({"Not an annotation. Skipping"})
        }
      } else {
        ParseEngine.log.debugFunc({"No completed matches"})
      }
    }
  }

  public reset() {
    ParseEngine.log.debugFunc({"Resetting parsers"})
    currentParsers.forEach({ _.reset() })
  }

  public clearTokensAfterParse(ParserBase parser) {
    ParseEngine.log.debugFunc({"Removing tokens from last parse: [#{parser.lastMatch.tokens.map(t => "'" + t.value + "'").join(", ")}]"})
    parser.lastMatch.tokens.forEach({
      if (tokens.isNotEmpty) {
        tokens.shift()
      }
    })

    if (tokens.isNotEmpty) {
      ParseEngine.log.debugFunc({"Checking statement end for token '#{tokens.first.value}'"})
      if (isStatementEnd(tokens.first)) {
        resetCurrentScope()
      } else {
        ParseEngine.log.debugFunc({"Not statement end"})
      }
    } else {
      ParseEngine.log.debugFunc({"No tokens left after clearing tokens"})
    }

    reset()

    tokens.forEach({ matchToken(_) })
  }

  public generateNode(ParserBase parser) -> Node {
    ParseEngine.log.debugFunc({"Generating node for parser: #{parser.class.name}"})
    let node = parser.generateNode(context, parser.lastMatch)

    if (!node) {
      throw Exception("Failed to parse node for parser: #{parser}")
    }

    stream.emit("data", node)$

    return node
  }

  public generateAnnotation(AnnotationParser parser) -> AnnotationNode {
    ParseEngine.log.debugFunc({"Generating annotation for parser: #{parser.class.name}"})
    let node = parser.generateNode(context, parser.lastMatch)

    if (!node) {
      throw Exception("Failed to parse annotation for parser: #{parser}")
    }

    return node
  }

  public updateScopeForNode(ParserBase parser, Node node) {
    match node.class {
      FileNode.class => fallthrough
      ClassNode.class => fallthrough
      FunctionNode.class => fallthrough
      FileScopeNode.class => fallthrough
      ClassScopeNode.class => fallthrough
      FunctionScopeNode.class => fallthrough
      ScopeNode.class => pushScope(parser, node)
      default => {
        if (let childParsers = parser.childParsers) {
          currentNode = node
          currentParser = parser
          currentParsers = childParsers
          context = context.copy(parentStack: parentStack.copy():push(currentNode))
        }
      }
    }
  }

  public tryGenerateNodeForRemainingTokens() {
    if (tokens.isEmpty) return

    if (!containsCompletedMatches()) {
      ParseEngine.log.debugFunc({"No completed matches. Not generating node"})
      invalidTokens()
      return
    }

    let parser = getBestMatch(getCompletedMatches())
    let node = generateNode(parser)
    updateScopeForNode(parser, node)
    clearTokensAfterParse(parser)
  }

  public checkStatementEnd(Token token) {
    if (isStatementEnd(token)) {
      ParseEngine.log.debugFunc({"Reached end of statement (token: #{token.value}). Generating node"})
      tryGenerateNodeForRemainingTokens()
    } else {
      ParseEngine.log.debugFunc({"Not end of statement"})
    }
  }

  public isStatementEnd(Token token) => false {
    if (tokens.isEmpty) return false

    return !currentParser.checkStatementContinuation(context, token)
  }

  public resetCurrentScope() {
    ParseEngine.log.debugFunc({"Resetting current scope"})
    currentNode = parentStack.peek()
    currentParser = parserStack.peek()
    currentParsers = parsersStack.peek()
    context = context.copy(
      parentStack: parentStack.copy(),
      annotations: Array()
    )
  }

  public pushScope(ParserBase parser, Node node) {
    ParseEngine.log.debugFunc({"Pushing node to parent stack: #{node} (parser: #{parser.class.name})"})
    currentNode = parentStack.push(node)
    currentParser = parserStack.push(parser)
    currentParsers = parsersStack.push(parser.childParsers)
    context = context.copy(parentStack: parentStack.copy())
  }

  public popScope(Token token) {
    if (parentStack.count > 1) {
      ParseEngine.log.debugFunc({"Popping node from parent stack: #{parentStack.peek()}"})
      currentNode = parentStack:pop().peek()
      currentParser = parserStack:pop().peek()
      currentParsers = parsersStack:pop().peek()
      context = context.copy(parentStack: parentStack.copy())
    } else {
      ParseEngine.log.errorFunc({"Unexpected '}' at #{token.location.lineNumber}:#{token.location.column}"})
    }
  }

  public invalidTokens() {
    invalidTokensError(tokens)
    resetCurrentScope()
    reset()
    tokens = Token[]
  }

  public invalidTokensError(Token[] tokens) {
    ParseEngine.log.debugFunc({"Could not parse tokens [#{tokens.map(t => "'" + t.value + "'").join(", ")}]. Resetting tokens. Parser #{currentParser.class.name}"})
    if (tokens.isNotEmpty && tokens.first.location) {
      let location = if (tokens.count == 1 && tokens.first.value.count == 1) {
        "#{tokens.first.location.lineNumber}:#{tokens.first.location.column}"
      } else {
        "#{tokens.first.location.lineNumber}:#{tokens.first.location.column}-#{tokens.last.endLineNumber}:#{tokens.last.endColumn}"
      }

      ParseEngine.log.errorFunc({"Could not parse tokens [#{tokens.map(t => "'" + t.value + "'").join(", ")}] at #{location}"})
    }
  }
}