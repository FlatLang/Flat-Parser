package flat/parser

import flat/datastruct/HashMap
import flat/parser/Parser
import flat/ast/FileNode
import flat/ast/PackageNode
import flat/compiler/models/Token
import flat/io/File

testable class {
  async test `can match package matcher group`() {
    let matcherGroup = TokenMatcherGroup([
      TokenMatcher(Token.Type.IDENTIFIER, "package"),
      TokenMatcher(Token.Type.IDENTIFIER, label: "package_location_component")
    ])

    let result = matcherGroup.matches([
      Token(value: "package", type: Token.Type.IDENTIFIER),
      Token(value: "test", type: Token.Type.IDENTIFIER)
    ])

    let expected = TokenMatch(
      HashMap()
        :add(
          "package_location_component",
          Array():addAll(["test"])
        )
    )

    expect(result).toBe(expected)
  }

  async test `can match package matcher group with unmatched optional repeating package_location_component`() {
    let matcherGroup = TokenMatcherGroup([
      TokenMatcher(Token.Type.IDENTIFIER, "package"),
      TokenMatcher(Token.Type.IDENTIFIER, label: "package_location_component"),
      TokenMatcherGroup([
        TokenMatcher(Token.Type.SYMBOL, "/", label: "package_location_component"),
        TokenMatcher(Token.Type.IDENTIFIER, label: "package_location_component")
      ], repeat: true, optional: true)
    ])

    let result = matcherGroup.matches([
      Token(value: "package", type: Token.Type.IDENTIFIER),
      Token(value: "test", type: Token.Type.IDENTIFIER)
    ])

    let expected = TokenMatch(
      HashMap()
        :add(
          "package_location_component",
          Array():addAll(["test"])
        )
    )

    expect(result).toBe(expected)
  }

  async test `can match package matcher group with matched optional repeating package_location_component`() {
    let matcherGroup = TokenMatcherGroup([
      TokenMatcher(Token.Type.IDENTIFIER, "package"),
      TokenMatcher(Token.Type.IDENTIFIER, label: "package_location_component"),
      TokenMatcherGroup([
        TokenMatcher(Token.Type.SYMBOL, "/", label: "package_location_component"),
        TokenMatcher(Token.Type.IDENTIFIER, label: "package_location_component")
      ], repeat: true, optional: true)
    ])

    let result = matcherGroup.matches([
      Token(value: "package", type: Token.Type.IDENTIFIER),
      Token(value: "test", type: Token.Type.IDENTIFIER),
      Token(value: "/", type: Token.Type.SYMBOL),
      Token(value: "thing", type: Token.Type.IDENTIFIER),
      Token(value: "/", type: Token.Type.SYMBOL),
      Token(value: "thing2", type: Token.Type.IDENTIFIER)
    ])

    let expected = TokenMatch(
      HashMap()
        :add(
          "package_location_component",
          Array():addAll(["test", "/", "thing", "/", "thing2"])
        )
    )

    expect(result).toBe(expected)
  }
}
