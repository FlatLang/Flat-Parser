package flat/parser

import flat/datastruct/HashMap
import flat/parser/Parser
import flat/ast/FileNode
import flat/ast/PackageNode
import flat/compiler/models/Token
import flat/io/File

testable class {
  async test `can match package matcher group`() {
    let matcherGroup = TokenMatcherGroup([
      TokenMatcher(Token.Type.IDENTIFIER, "package"),
      TokenMatcher(Token.Type.IDENTIFIER, label: "package_location_component")
    ])

    let result = matcherGroup.matches([
      Token(value: "package", type: Token.Type.IDENTIFIER),
      Token(value: "test", type: Token.Type.IDENTIFIER)
    ])

    let expected = HashMap()
      :add(
        "package_location_component",
        Array():addAll(["test"])
      )

    expect(result?.values).toBe(expected)
  }

  async test `can match package matcher group with unmatched optional repeating package_location_component`() {
    let matcherGroup = TokenMatcherGroup([
      TokenMatcher(Token.Type.IDENTIFIER, "package"),
      TokenMatcher(Token.Type.IDENTIFIER, label: "package_location_component"),
      TokenMatcherGroup([
        TokenMatcher(Token.Type.SYMBOL, "/", label: "package_location_component"),
        TokenMatcher(Token.Type.IDENTIFIER, label: "package_location_component")
      ], repeat: true, optional: true)
    ])

    let result = matcherGroup.matches([
      Token(value: "package", type: Token.Type.IDENTIFIER),
      Token(value: "test", type: Token.Type.IDENTIFIER)
    ])

    let expected = HashMap()
      :add(
        "package_location_component",
        Array():addAll(["test"])
      )

    expect(result?.values).toBe(expected)
  }

  async test `can match package matcher group with matched optional repeating package_location_component`() {
    let matcherGroup = TokenMatcherGroup([
      TokenMatcher(Token.Type.IDENTIFIER, "package"),
      TokenMatcher(Token.Type.IDENTIFIER, label: "package_location_component"),
      TokenMatcherGroup([
        TokenMatcher(Token.Type.SYMBOL, "/", label: "package_location_component"),
        TokenMatcher(Token.Type.IDENTIFIER, label: "package_location_component")
      ], repeat: true, optional: true)
    ])

    let result = matcherGroup.matches([
      Token(value: "package", type: Token.Type.IDENTIFIER),
      Token(value: "test", type: Token.Type.IDENTIFIER),
      Token(value: "/", type: Token.Type.SYMBOL),
      Token(value: "thing", type: Token.Type.IDENTIFIER),
      Token(value: "/", type: Token.Type.SYMBOL),
      Token(value: "thing2", type: Token.Type.IDENTIFIER)
    ])

    let expected = HashMap()
      :add(
        "package_location_component",
        Array():addAll(["test", "/", "thing", "/", "thing2"])
      )

    expect(result?.values).toBe(expected)
  }

  async test `can match multiple nested matcher groups with matched optional repeating values`() {
    let matcherGroup = TokenMatcherGroup([
      TokenMatcher(Token.Type.IDENTIFIER, "class"),
      TokenMatcher(Token.Type.IDENTIFIER, label: "class_name", optional: true, greedy: false),
      TokenMatcherGroup([
        TokenMatcher(Token.Type.IDENTIFIER, "extends"),
        TokenMatcher(Token.Type.IDENTIFIER, label: "extends_class_name")
      ], optional: true),
      TokenMatcherGroup([
        TokenMatcher(Token.Type.IDENTIFIER, "implements"),
        TokenMatcher(Token.Type.IDENTIFIER, label: "implements_class_name"),
        TokenMatcherGroup([
          TokenMatcher(Token.Type.SYMBOL, ","),
          TokenMatcher(Token.Type.IDENTIFIER, label: "implements_class_name")
        ], repeat: true, optional: true)
      ], optional: true)
    ])

    let result = matcherGroup.matches([
      Token(value: "class", type: Token.Type.IDENTIFIER),
      Token(value: "extends", type: Token.Type.IDENTIFIER),
      Token(value: "Extended", type: Token.Type.IDENTIFIER),
      Token(value: "implements", type: Token.Type.IDENTIFIER),
      Token(value: "I1", type: Token.Type.IDENTIFIER),
      Token(value: ",", type: Token.Type.SYMBOL),
      Token(value: "I2", type: Token.Type.IDENTIFIER),
      Token(value: ",", type: Token.Type.SYMBOL),
      Token(value: "I3", type: Token.Type.IDENTIFIER)
    ])

    let expected = HashMap()
      :add("extends_class_name", Array():addAll(["Extended"]))
      :add("implements_class_name", Array():addAll(["I1", "I2", "I3"]))

    expect(result?.values).toBe(expected)
  }

  async test `can match against matcher with multiple values`() {
    let matcherGroup = TokenMatcherGroup([
      TokenMatcher(Token.Type.IDENTIFIER, label: "alias", values: Array():addAll([
          "test1", "test2", "test3", "test4"
        ])
      )
    ])

    let result = matcherGroup.matches([
      Token(value: "test3", type: Token.Type.IDENTIFIER)
    ])

    let expected = HashMap()
      :add("alias", Array():addAll(["test3"]))

    expect(result?.values).toBe(expected)
  }

  async test `can match partially against matcher when too few tokens given`() {
    let matcherGroup = TokenMatcherGroup([
      TokenMatcher(Token.Type.IDENTIFIER, "package"),
      TokenMatcher(Token.Type.IDENTIFIER, label: "package_location_component"),
      TokenMatcherGroup([
        TokenMatcher(Token.Type.SYMBOL, "/", label: "package_location_component"),
        TokenMatcher(Token.Type.IDENTIFIER, label: "package_location_component")
      ], repeat: true, optional: true)
    ])

    let result = matcherGroup.matches([
      Token(value: "package", type: Token.Type.IDENTIFIER)
    ])

    let expected = TokenMatch(
      tokens: [Token(value: "package", type: Token.Type.IDENTIFIER)],
      partial: true
    )

    expect(result).toBe(expected)
  }

  async test `doesnt match partially against matcher when too few and incorrect tokens given`() {
    let matcherGroup = TokenMatcherGroup([
      TokenMatcher(Token.Type.IDENTIFIER, "import"),
      TokenMatcher(Token.Type.IDENTIFIER, label: "import_location_component"),
      TokenMatcherGroup([
        TokenMatcher(Token.Type.SYMBOL, "/", label: "import_location_component"),
        TokenMatcher(Token.Type.IDENTIFIER, label: "import_location_component")
      ], repeat: true, optional: true)
    ])

    let result = matcherGroup.matches([
      Token(value: "package", type: Token.Type.IDENTIFIER)
    ])

    expect(result).toBe(null)
  }

  async test `doesnt match partially against matcher when zero tokens given`() {
    let matcherGroup = TokenMatcherGroup([
      TokenMatcher(Token.Type.IDENTIFIER, "import"),
      TokenMatcher(Token.Type.IDENTIFIER, label: "import_location_component"),
      TokenMatcherGroup([
        TokenMatcher(Token.Type.SYMBOL, "/", label: "import_location_component"),
        TokenMatcher(Token.Type.IDENTIFIER, label: "import_location_component")
      ], repeat: true, optional: true)
    ])

    let result = matcherGroup.matches(Array())

    expect(result).toBe(null)
  }

  async test `doesnt match partially against matcher when too many tokens that dont match are given`() {
    let matcherGroup = TokenMatcherGroup([
      TokenMatcher(Token.Type.IDENTIFIER, "class"),
      TokenMatcher(Token.Type.IDENTIFIER, label: "class_name", optional: true, greedy: false),
      TokenMatcherGroup([
        TokenMatcher(Token.Type.IDENTIFIER, "extends"),
        TokenMatcher(Token.Type.IDENTIFIER, label: "extends_class_name")
      ], optional: true),
      TokenMatcherGroup([
        TokenMatcher(Token.Type.IDENTIFIER, "implements"),
        TokenMatcher(Token.Type.IDENTIFIER, label: "implements_class_name"),
        TokenMatcherGroup([
          TokenMatcher(Token.Type.SYMBOL, ","),
          TokenMatcher(Token.Type.IDENTIFIER, label: "implements_class_name")
        ], repeat: true, optional: true)
      ], optional: true)
    ])

    let result = matcherGroup.matches([
      Token(value: "class", type: Token.Type.IDENTIFIER),
      Token(value: "{", type: Token.Type.SYMBOL),
      Token(value: "public", type: Token.Type.IDENTIFIER),
      Token(value: "static", type: Token.Type.IDENTIFIER),
      Token(value: "async", type: Token.Type.IDENTIFIER),
      Token(value: "main", type: Token.Type.IDENTIFIER),
      Token(value: "(", type: Token.Type.SYMBOL),
      Token(value: "String", type: Token.Type.IDENTIFIER),
      Token(value: "[", type: Token.Type.SYMBOL),
      Token(value: "]", type: Token.Type.SYMBOL),
      Token(value: "args", type: Token.Type.IDENTIFIER),
      Token(value: ")", type: Token.Type.SYMBOL),
      Token(value: "{", type: Token.Type.SYMBOL)
    ])

    expect(result).toBe(null)
  }

  async test `matches completely against just first identifier if all others are optional`() {
    let matcherGroup = TokenMatcherGroup([
      TokenMatcher(Token.Type.IDENTIFIER, "class"),
      TokenMatcher(Token.Type.IDENTIFIER, label: "class_name", optional: true, greedy: false),
      TokenMatcherGroup([
        TokenMatcher(Token.Type.IDENTIFIER, "extends"),
        TokenMatcher(Token.Type.IDENTIFIER, label: "extends_class_name")
      ], optional: true),
      TokenMatcherGroup([
        TokenMatcher(Token.Type.IDENTIFIER, "implements"),
        TokenMatcher(Token.Type.IDENTIFIER, label: "implements_class_name"),
        TokenMatcherGroup([
          TokenMatcher(Token.Type.SYMBOL, ","),
          TokenMatcher(Token.Type.IDENTIFIER, label: "implements_class_name")
        ], repeat: true, optional: true)
      ], optional: true)
    ])

    let result = matcherGroup.matches([
      Token(value: "class", type: Token.Type.IDENTIFIER)
    ])

    let expected = TokenMatch(
      tokens: [Token(value: "class", type: Token.Type.IDENTIFIER)],
      partial: false
    )

    expect(result).toBe(expected)
  }
}
