package flat/parser

import flat/datastruct/list/Stack
import flat/ast/Node
import flat/ast/AnnotationNode
import flat/ast/FileNode
import flat/compiler/models/Token
import flat/io/File
import flat/log/Logger
import flat/stream/Stream

class {
  let static Logger log = Logger(Parser.class)

  public async parse(File file, Stream tokenStream) -> Stream {
    let fileNode = FileNode(file: file)

    return parse(fileNode, tokenStream)
  }

  async parse(FileNode fileNode, Stream tokenStream) -> Stream {
    let stream = Stream(true)

    let handler = ParseHandler(fileNode, stream)

    tokenStream.on<Token>("data", (token) => {
      Parser.log.traceFunc({"Received data from Token Stream: #{token}"})

      handler.consume(token)
    })$

    tokenStream.on<String>("error", (error) => {
      Parser.log.traceFunc({"Received error from Token Stream: #{error}"})
      stream.emit("error", error)$
    })$

    tokenStream.on("close", {
      Parser.log.traceFunc({"Token Stream closed"})
      stream.emit("close")$
    })$

    return stream
  }

  private class ParseHandler {
    Stack<Node> parentStack = Stack()
    Stack<ParserBase> parserStack = Stack()

    let AnnotationParser annotationParser = AnnotationParser()

    var ParserResult[] currentResults = ParserResult[]
    var ParserResult[] matchedResults = ParserResult[]
    var ParserResult[] annotationResults = ParserResult[]
    var Token[] tokens = Token[]
    var ParseContext context = ParseContext()

    private data class ParserResult {
      visible ParserBase parser
      visible TokenMatch match
    }

    private data class NodeResult {
      visible ParserBase parser
      visible Node node
    }

    construct(
      private FileNode fileNode,
      private Stream stream
    ) {
      parentStack.push(fileNode)
      parserStack.push(FileParser())
      context = context.copy(parent: parentStack.peek())

      resetCurrentResults()
    }

    resetCurrentResults() {
      currentResults = parserStack.peek().childParsers.map({ ParserResult(_, null) })
      matchedResults = ParserResult[]
      annotationResults = ParserResult[]
    }

    async consume(Token token) {
      match token.type {
        Token.Type.WS => return
        Token.Type.SYMBOL => {
          match token.value {
            "{" => {
              if (let result = generateNode()) {
                parentStack.push(result.node)
                parserStack.push(result.parser)
                resetCurrentResults()
              }
              return
            }
            "}" => {
              if (tokens.isNotEmpty) {
                generateNode()
              }
              if (parentStack.count > 1) {
                parentStack.pop()
                parserStack.pop()
              } else {
                Parser.log.errorFunc({"Unexpected '}' at #{token.location.lineNumber}:#{token.location.column}"})
              }
              resetCurrentResults()
              return
            }
          }
        }
      }

      let parent = parentStack.peek()
      let parser = parserStack.peek()

      Parser.log.debugFunc({"Adding token value: '#{token.value}' type: #{token.type}"})

      tokens.add(token)

      consume()
    }

    async consume() {
      Parser.log.debugFunc({"Matching tokens: [#{tokens.map(t => "'" + t.value + "'").join(", ")}]"})

      let ParserResult[] results = currentResults.mapNotNull((result) => {
        if (let match = result.parser.matcher.matches(tokens)) {
          if (!match.partial) {
             Parser.log.debugFunc({"Matched: #{result.parser.class.name}: #{match.values}"})
          } else {
             Parser.log.debugFunc({"Partial match: #{result.parser.class.name}: #{match.values}"})
          }
          return result.copy(match: match)
        }

        return null
      }).toArray()

      Parser.log.debugFunc({"Result count: #{results.count}"})

      if (results.isEmpty) {
        generateNode()
      } else {
        currentResults = results

        annotationResults = currentResults
          .filter({ _.match != null })
          .filter({ !_.match.partial })
          .filter({ _.parser.class.isOfType(AnnotationParser.class) })
          .sort({ _.match.tokens.count - _.match.tokens.count })

        if (annotationResults.isNotEmpty) {
          generateAnnotation()
        } else {
          Parser.log.debugFunc({"|
            Carrying over results:
              #{results.map(x => x.parser.class.name + ": " + x.match.values + " partial: " + x.match.partial).join("\n  ")}
            |"})
        }
      }
    }

    async generateNode() -> NodeResult => null {
      Parser.log.debugFunc({"Generating Node"})

      var NodeResult nodeResult = null

      matchedResults = currentResults
        .filter({ _.match != null })
        .filter({ !_.match.partial })
        .sort({ _.match.tokens.count - _.match.tokens.count })

      if (matchedResults.isNotEmpty) {
        Parser.log.debugFunc({"|
          Matched results:
            #{matchedResults.map(x => x.parser.class.name + ": " + x.match.values).join("\n  ")}
          |"})

        let result = matchedResults.first
        let matchedTokens = result.match.tokens
        tokens = tokens.skip(matchedTokens.count)

        let node = result.parser.generateNode(context, result.match)

        if (node) {
          let nodeWithContext = node.copy(
            parent: parentStack.peek(),
            annotations: context.annotations
          )
          Parser.log.debugFunc({"Parsed node: #{node}"})
          stream.emit("data", nodeWithContext)$

          nodeResult = NodeResult(result.parser, nodeWithContext)
        } else {
          Parser.log.debugFunc({"Could not generate node for tokens [#{matchedTokens.map(t => "'" + t.value + "'").join(", ")}]"})
        }
      } else {
        invalidTokens()
      }

      resetCurrentResults()
      context = context.copy(annotations: AnnotationNode[])

      if (tokens.isNotEmpty) {
        consume()
      }

      return nodeResult
    }

    async generateAnnotation() -> NodeResult => null {
      Parser.log.debugFunc({"Generating Annotation"})

      var NodeResult nodeResult = null

      if (annotationResults.isNotEmpty) {
        Parser.log.debugFunc({"|
          Annotation results:
            #{annotationResults.map(x => x.parser.class.name + ": " + x.match.values).join("\n  ")}
          |"})

        let result = annotationResults.first
        let matchedTokens = result.match.tokens
        tokens = tokens.skip(matchedTokens.count)

        let node = result.parser.generateNode(context, result.match)

        if (node) {
          let nodeWithContext = node.copy(
            parent: parentStack.peek()
          )
          Parser.log.debugFunc({"Parsed annotation: #{node}"})
          context.annotations.add((AnnotationNode)nodeWithContext)

          nodeResult = NodeResult(result.parser, nodeWithContext)
        } else {
          Parser.log.debugFunc({"Could not generate annotation node for tokens [#{matchedTokens.map(t => "'" + t.value + "'").join(", ")}]"})
        }
      } else {
       invalidTokens()
      }

      resetCurrentResults()

      if (tokens.isNotEmpty) {
        consume()
      }

      return nodeResult
    }

    invalidTokens() {
      Parser.log.debugFunc({"Could not parse tokens [#{tokens.map(t => "'" + t.value + "'").join(", ")}]. Resetting tokens"})
      Parser.log.traceFunc({"matchedResults: #{matchedResults}"})
      if (tokens.isNotEmpty) {
        Parser.log.errorFunc({"Could not parse tokens [#{tokens.map(t => "'" + t.value + "'").join(", ")}] at #{tokens.first.location.lineNumber}:#{tokens.first.location.column}-#{tokens.last.endLineNumber}:#{tokens.last.endColumn}"})
      }
      tokens = Token[]
    }
  }
}