package flat/parser

import flat/datastruct/list/Stack
import flat/ast/Node
import flat/ast/AnnotationNode
import flat/ast/FileNode
import flat/ast/ScopeNode
import flat/compiler/models/Token
import flat/io/File
import flat/log/Logger
import flat/stream/Stream

class {
  let static Logger log = Logger(Parser.class)

  public async parse(File file, Stream tokenStream) -> Stream {
    let fileNode = FileNode(file: file)

    return parse(fileNode, tokenStream)
  }

  async parse(FileNode fileNode, Stream tokenStream) -> Stream {
    let stream = Stream(true)

    stream.emit("data", fileNode)$

    let handler = ParseHandler(fileNode, stream)

    tokenStream.on<Token>("data", (token) => {
      Parser.log.traceFunc({"Received data from Token Stream: #{token}"})

      handler.consume(token)
    })

    tokenStream.on<String>("error", (error) => {
      Parser.log.traceFunc({"Received error from Token Stream: #{error}"})
      stream.emit("error", error)$
    })

    tokenStream.on("close", {
      Parser.log.traceFunc({"Token Stream closed"})
      stream.emit("close")$
    })

    return stream
  }

  private class ParseHandler {
    Stack<Node> parentStack = Stack()
    Stack<ParserBase> parserStack = Stack()

    let AnnotationParser annotationParser = AnnotationParser()

    var ParserResult[] currentResults = ParserResult[]
    var ParserResult[] matchedResults = ParserResult[]
    var ParserResult[] annotationResults = ParserResult[]
    var Token[] tokens = Token[]
    var ParseContext context = ParseContext()
    var Node currentNode
    var ParserBase currentParser

    private data class ParserResult {
      visible ParserBase parser
      visible TokenMatch match
    }

    private data class NodeResult {
      visible ParserBase parser
      visible Node node
    }

    construct(
      private FileNode fileNode,
      private Stream stream
    ) {
      parentStack.push(fileNode)
      parserStack.push(FileParser())

      resetCurrentResults(true)
    }

    resetCurrentResults(Bool resetCurrentNode = false) {
      matchedResults = ParserResult[]
      annotationResults = ParserResult[]
      if (resetCurrentNode) {
        currentNode = parentStack.peek()
        currentParser = parserStack.peek()
      }
      context = context.copy(parentStack: parentStack.copy():push(currentNode))
      currentResults = currentParser.childParsers.map({ ParserResult(_, null) })
      Parser.log.debugFunc({"Set parent to #{currentNode.class.name}"})
    }

    consume(Token token) {
      match token.type {
        Token.Type.WS => return
      }

      checkStatementEnd(token)

      Parser.log.debugFunc({"Adding token value: '#{token.value}' type: #{token.type}"})

      tokens.add(token)

      consume()
    }

    checkStatementEnd(Token token) {
      if (isStatementEnd(token)) {
        Parser.log.debugFunc({"Reached end of statement (token: #{token.value}). Generating node"})
        generateNode()
      } else {
        Parser.log.debugFunc({"Not end of statement"})
      }
    }

    isStatementEnd(Token token) => false {
      if (tokens.isEmpty) return false

      return !currentParser.checkStatementContinuation(context, token)
    }

    popScope() {
      Parser.log.debugFunc({"Encountered closing brace"})
      if (parentStack.count > 1) {
        let node = parentStack.pop()
        parserStack.pop()
        Parser.log.debugFunc({"Popped node from parent stack: #{node}"})
      } else {
        let token = tokens.first
        Parser.log.errorFunc({"Unexpected '}' at #{token.location.lineNumber}:#{token.location.column}"})
      }
      resetCurrentResults(true)
    }

    match() -> ParserResult[] {
      Parser.log.debugFunc({"Matching tokens: [#{tokens.map(t => "'" + t.value + "'").join(", ")}]"})

      let ParserResult[] results = currentResults.mapNotNull((result) => {
        if (let match = result.parser.matcher.matches(tokens)) {
          if (!match.partial) {
             Parser.log.debugFunc({"Matched: #{result.parser.class.name}: #{match.values}"})
          } else {
             Parser.log.debugFunc({"Partial match: #{result.parser.class.name}: #{match.values}"})
          }
          return result.copy(match: match)
        }

        return null
      })

      Parser.log.debugFunc({"Result count: #{results.count}"})

      return results
    }

    consume() {
      let results = match()

      if (results.isEmpty) {
        generateNode(true)
      } else {
        currentResults = results

        annotationResults = getSortedResults(currentResults.filter({ _.parser.class.isOfType(AnnotationParser.class) }))

        if (annotationResults.isNotEmpty) {
          generateAnnotation()
        } else {
          Parser.log.debugFunc({"|
            Carrying over results:
              #{results.map(x => x.parser.class.name + ": " + x.match.values + " partial: " + x.match.partial).join("\n  ")}
            |"})
        }
      }
    }

    getSortedResults(ParserResult[] results) => results
      .filter({ _.match != null })
      .filter({ !_.match.partial })
      .sort({ _.match.tokens.count - _.match.tokens.count })

    generateNode(Bool postConsume = false) -> NodeResult => null {
      Parser.log.debugFunc({"Generating Node"})

      var NodeResult nodeResult = null

      matchedResults = getSortedResults(currentResults)

      if (matchedResults.isNotEmpty) {
        Parser.log.debugFunc({"|
          Matched results:
            #{matchedResults.map(x => x.parser.class.name + ": " + x.match.values).join("\n  ")}
          |"})

        let result = matchedResults.first
        let matchedTokens = result.match.tokens
        tokens = tokens.skip(matchedTokens.count)

        let node = result.parser.generateNode(context, result.match)

        if (node) {
          Parser.log.debugFunc({"Parsed node: #{node}"})

          let nodeWithContext = node.copy(
            annotations: context.annotations
          )

          let nodeContext = context.copy(
            parentStack: parentStack.copy():push(nodeWithContext)
          )

          result.parser
            .getChildParseRequests(nodeContext, result.match)
            .requests
            .mapNotNull<Node>((request) => {
              let results = getSortedResults(
                request.parsers
                  .mapNotNull((parser) => {
                    return ParserResult(
                      parser: parser,
                      match: parser.matcher.matches(request.tokens)
                    )
                  })
              )

              if (results.isNotEmpty) {
                let result = results.first
                return result.parser.generateNode(nodeContext, result.match)
              } else {
                Parser.log.debugFunc({"Failed to parse child node for tokens: [#{request.tokens.map(t => "'" + t.value + "'").join(", ")}]"})
                invalidTokensError(request.tokens)
                return null
              }
            })
            .forEach((child) => {
              Parser.log.debugFunc({"Parsed child node: #{child}"})
              nodeWithContext.children.add(child)
            })

          currentNode.children.add(nodeWithContext)

          if (result.parser.childParsers != null) {
            currentNode = nodeWithContext
            currentParser = result.parser

            if (currentNode.class.isOfType(ScopeNode.class)) {
              parentStack.push(currentNode)
              parserStack.push(currentParser)
            }
          }

          stream.emit("data", nodeWithContext)$

          nodeResult = NodeResult(result.parser, nodeWithContext)
        } else {
          Parser.log.debugFunc({"Could not generate node for tokens [#{matchedTokens.map(t => "'" + t.value + "'").join(", ")}]"})
        }
      } else {
        if (tokens.count == 1 && tokens.first.value == "}") {
          popScope()
          tokens.shift()
          return null
        } else {
          invalidTokens()
        }
      }

      resetCurrentResults()
      context = context.copy(annotations: AnnotationNode[])

      if (postConsume && tokens.isNotEmpty) {
        if (isStatementEnd(tokens.first)) {
          Parser.log.debugFunc({"Reached statement end after generating node. Resetting current results"})
          resetCurrentResults(true)
        }

        consume()
      }

      return nodeResult
    }

    generateAnnotation() -> NodeResult => null {
      Parser.log.debugFunc({"Generating Annotation"})

      var NodeResult nodeResult = null

      if (annotationResults.isNotEmpty) {
        Parser.log.debugFunc({"|
          Annotation results:
            #{annotationResults.map(x => x.parser.class.name + ": " + x.match.values).join("\n  ")}
          |"})

        let result = annotationResults.first
        let matchedTokens = result.match.tokens
        tokens = tokens.skip(matchedTokens.count)

        let node = result.parser.generateNode(context, result.match)

        if (node) {
          Parser.log.debugFunc({"Parsed annotation: #{node}"})
          context.annotations.add((AnnotationNode)node)

          nodeResult = NodeResult(result.parser, node)
        } else {
          Parser.log.debugFunc({"Could not generate annotation node for tokens [#{matchedTokens.map(t => "'" + t.value + "'").join(", ")}]"})
        }
      } else {
       invalidTokens()
      }

      resetCurrentResults()

      if (tokens.isNotEmpty) {
        consume()
      }

      return nodeResult
    }

    invalidTokens() {
      invalidTokensError(tokens)
      tokens = Token[]
    }

    invalidTokensError(Token[] tokens) {
      Parser.log.debugFunc({"Could not parse tokens [#{tokens.map(t => "'" + t.value + "'").join(", ")}]. Resetting tokens"})
      Parser.log.traceFunc({"matchedResults: #{matchedResults}"})
      if (tokens.isNotEmpty) {
        Parser.log.errorFunc({"Could not parse tokens [#{tokens.map(t => "'" + t.value + "'").join(", ")}] at #{tokens.first.location.lineNumber}:#{tokens.first.location.column}-#{tokens.last.endLineNumber}:#{tokens.last.endColumn}"})
      }
    }
  }
}