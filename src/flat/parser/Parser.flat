package flat/parser

import flat/datastruct/list/Stack
import flat/ast/Node
import flat/ast/FileNode
import flat/compiler/models/Token
import flat/io/File
import flat/log/Logger
import flat/stream/Stream

class {
  let static Logger log = Logger(Parser.class)

  public async parse(File file, Stream tokenStream) -> Stream {
    let fileNode = FileNode(file: file)

    return parse(fileNode, tokenStream)
  }

  async parse(FileNode fileNode, Stream tokenStream) -> Stream {
    let stream = Stream(true)

    let handler = ParseHandler(fileNode, stream)

    tokenStream.on<Token>("data", (token) => {
      Parser.log.traceFunc({"Received data from Token Stream: #{token}"})

      handler.consume(token)
    })$

    tokenStream.on<String>("error", (error) => {
      Parser.log.traceFunc({"Received error from Token Stream: #{error}"})
      stream.emit("error", error)$
    })$

    tokenStream.on("close", {
      Parser.log.traceFunc({"Token Stream closed"})
      stream.emit("close")$
    })$

    return stream
  }

  private class ParseHandler {
    Stack<Node> parentStack = Stack()
    Stack<ParserBase> parserStack = Stack()

    var ParserResult[] currentResults = ParserResult[]
    var Token[] tokens = Token[]

    construct(
      private FileNode fileNode,
      private Stream stream
    ) {
      parentStack.push(fileNode)
      parserStack.push(FileParser())

      resetCurrentResults()
    }

    resetCurrentResults() {
      currentResults = parserStack.peek().childParsers.map({ ParserResult(_, null) })
    }

    async consume(Token token) {
      if (token.type == Token.Type.WS) return

      let parent = parentStack.peek()
      let parser = parserStack.peek()

      tokens.add(token)

      let results = currentResults.mapNotNullAsync((result) => {
        if (let match = result.parser.pattern.matches(tokens)) {
          return result.copy(match: match)
        }

        return null
      }).toArray()

      if (results.isEmpty) {
        if (currentResults.count == 1) {
          let result = currentResults.first

          if (!result.match.partial) {
            let matchedTokens = result.match.tokens
            tokens = tokens.skip(matchedTokens.count)

            let context = ParseContext(
              parent: fileNode
            )

            stream.emit("data", result.parser.generateNode(context, result.match))$
          }
        } else {
          // throw syntax error
          tokens = Token[]
        }

        resetCurrentResults()
      } else {
        currentResults = results
      }
    }

    private data class ParserResult {
      visible ParserBase parser
      visible TokenMatch match
    }
  }
}