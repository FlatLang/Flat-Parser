package flat/parser/flat

import flat/parser
import flat/parser/matchers
import flat/ast
import flat/annotations
import flat/compiler/models/Token
import flat/lexer/Lexer
import flat/io/File

testable class {
  async test `can parse function call with complex lambda`() {
    let source = "|
      class {
        func() {
          source.forEach((Pair<String, Object> pair) => {
            if (!dest.containsKey(pair.key)) {
              dest[pair.key] = pair.value
            }

            if (pair.value.class.isOfType(HashMap.class)) {
              let HashMap<String, Object> hashmap = (HashMap)pair.value
              let HashMap<String, Object> existingHashmap = (HashMap)dest[pair.key]
              merge(hashmap, existingHashmap)
            } else {
              dest[pair.key] = pair.value
            }
          })
        }
      }
      |"

    let file = File("Test.flat")
    let stream = Parser().parse(
      FileParser(),
      ParseContext(file: file),
      Lexer().lex(source):emit("start")
    )

    let nodes = Node[]

    stream.on<Node>("data", { nodes.add(_) })
    stream.emit("start")
    stream.waitFor("close")

    expect(nodes).toBe([
      ClassNode(),
      FunctionNode(), IdentifierNode(name: "func"),
      IdentifierNode(name: "source"), DotAccessNode(), FunctionCallNode(), IdentifierNode(name: "forEach"), LambdaNode(), LocalScopeNode(),
        IfNode(), PriorityNode(),
          UnaryOperationNode(operator: "!"), IdentifierNode(name: "dest"), DotAccessNode(), FunctionCallNode(), IdentifierNode(name: "containsKey"),
            IdentifierNode(name: "pair"), DotAccessNode(), IdentifierNode(name: "key"),
        LocalScopeNode(),
          IdentifierNode(name: "dest"), ArrayAccessNode(), IdentifierNode(name: "pair"), DotAccessNode(), IdentifierNode(name: "key"),
            AssignmentNode(),
            IdentifierNode(name: "pair"), DotAccessNode(), IdentifierNode(name: "value"),
        IfNode(), PriorityNode(),
          IdentifierNode(name: "pair"), DotAccessNode(), IdentifierNode(name: "value"), DotAccessNode(), IdentifierNode(name: "class"), DotAccessNode(), FunctionCallNode(), IdentifierNode(name: "isOfType"),
            IdentifierNode(name: "HashMap"), DotAccessNode(), IdentifierNode(name: "class"),
        LocalScopeNode(),
          LocalDeclarationNode(), LetModifier(),
              TypeNode(name: "HashMap"), GenericParametersNode(),
                GenericParameterNode(), TypeNode(name: "String"),
                GenericParameterNode(), TypeNode(name: "Object"),
              IdentifierNode(name: "hashmap"),
            AssignmentNode(),
            CastNode(), TypeNode(name: "HashMap"), IdentifierNode(name: "pair"), DotAccessNode(), IdentifierNode(name: "value"),
          LocalDeclarationNode(), LetModifier(),
              TypeNode(name: "HashMap"), GenericParametersNode(),
                GenericParameterNode(), TypeNode(name: "String"),
                GenericParameterNode(), TypeNode(name: "Object"),
              IdentifierNode(name: "existingHashmap"),
            AssignmentNode(),
            CastNode(), TypeNode(name: "HashMap"), IdentifierNode(name: "dest"), ArrayAccessNode(), IdentifierNode(name: "pair"), DotAccessNode(), IdentifierNode(name: "key"),
          FunctionCallNode(), IdentifierNode(name: "merge"), IdentifierNode(name: "hashmap"), IdentifierNode(name: "existingHashmap"),
        ElseNode(),
          LocalScopeNode(), IdentifierNode(name: "dest"), ArrayAccessNode(), IdentifierNode(name: "pair"), DotAccessNode(), IdentifierNode(name: "key"),
          AssignmentNode(),
          IdentifierNode(name: "pair"), DotAccessNode(), IdentifierNode(name: "value")
    ])
  }

  async test `can parse function call with if-else-if lambda`() {
    let source = "|
      class {
        func() {
          context.currentParsers.forEach((parser) => {
            if (let match = parser.match(token, context)) {
              ParseEngine.log.debugFunc({\"Matched: \#{parser.class.name}\"})
            } else if (parser.matcher.partial) {
              ParseEngine.log.debugFunc({\"Partial match: \#{parser.class.name}\"})
            }
          })
        }
      }
      |"

    let file = File("Test.flat")
    let stream = Parser().parse(
      FileParser(),
      ParseContext(file: file),
      Lexer().lex(source):emit("start")
    )

    let nodes = Node[]

    stream.on<Node>("data", { nodes.add(_) })
    stream.emit("start")
    stream.waitFor("close")

    expect(nodes).toBe([
      ClassNode(),
      FunctionNode(), IdentifierNode(name: "func"),
        IdentifierNode(name: "context"), DotAccessNode(), IdentifierNode(name: "currentParsers"), DotAccessNode(), FunctionCallNode(), IdentifierNode(name: "forEach"), LambdaNode(), LocalScopeNode(),
          IfNode(), PriorityNode(),
            LocalDeclarationNode(), LetModifier(),
              IdentifierNode(name: "match"),
            AssignmentNode(),
            IdentifierNode(name: "parser"), DotAccessNode(), FunctionCallNode(), IdentifierNode(name: "match"), IdentifierNode(name: "token"), IdentifierNode(name: "context"),
          LocalScopeNode(),
            IdentifierNode(name: "ParseEngine"), DotAccessNode(), IdentifierNode(name: "log"), DotAccessNode(), FunctionCallNode(), IdentifierNode(name: "debugFunc"),
              LambdaNode(), LocalScopeNode(), StringLiteralNode(value: "\"Matched: \#{parser.class.name}\""),
          ElseNode(), IfNode(), PriorityNode(),
            IdentifierNode(name: "parser"), DotAccessNode(), IdentifierNode(name: "matcher"), DotAccessNode(), IdentifierNode(name: "partial"),
          LocalScopeNode(),
            IdentifierNode(name: "ParseEngine"), DotAccessNode(), IdentifierNode(name: "log"), DotAccessNode(), FunctionCallNode(), IdentifierNode(name: "debugFunc"),
              LambdaNode(), LocalScopeNode(), StringLiteralNode(value: "\"Partial match: \#{parser.class.name}\"")
    ])
  }
}
