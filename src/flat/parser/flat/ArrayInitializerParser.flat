package flat/parser/flat

import flat/parser
import flat/parser/matchers
import flat/ast/ArrayInitializerNode
import flat/compiler/models/Token
import flat/compiler/models/SyntaxTokenFunctions

data class extends ParserBase {
  override ParserBase[] childParsers => Array():addAll([
    DotAccessParser(),
    ColonAccessParser(),
    AssignmentParser(),
    ArrayAccessParser()
  ])

  override lazy TokenPattern pattern => GroupTokenPattern([
    SingleTokenPattern(Token.Type.SYMBOL, "["),
    GroupTokenPattern([
      NodeTokenPattern(indexParsers, label: "initializer_value"),
      GroupTokenPattern([
        SingleTokenPattern(Token.Type.SYMBOL, ","),
        NodeTokenPattern(indexParsers, label: "initializer_value")
      ], optional: true, repeat: true)
    ], label: "initializer_values"),
    SingleTokenPattern(Token.Type.SYMBOL, "]")
  ])

  let ParserBase[] indexParsers => [
    AnnotationParser(),
    FunctionCallParser(),
    IdentifierParser(),
    LiteralParser(),
    RegexPatternParser(),
    LambdaParser(),
    ArrayInitializerParser()
  ]

  override public checkStatementContinuation(ParseContext context, Token token) => token.type == Token.Type.SYMBOL {
    match token.value {
      "{" => return false
    }
  }

  override public generateNode(ParseContext context, TokenMatch match) -> ArrayInitializerNode {
    return ArrayInitializerNode()
  }

  override public getChildNodeTokenMatches(ParseContext context, TokenMatch match) => NodeTokenMatch[] {
    if (let args = match.getMatch<GroupTokenMatch>("initializer_values")) {
      return (NodeTokenMatch[])args.tokenMatches.filter({ _.label == "initializer_value" })
    }
  }
}