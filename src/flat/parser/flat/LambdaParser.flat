package flat/parser/flat

import flat/parser
import flat/parser/matchers
import flat/ast/LambdaNode
import flat/compiler/models/Token

data class extends ParserBase implements ScopeableParser {
  override lazy TokenPattern pattern => XorTokenPattern([
    XorTokenPattern([
      GroupTokenPattern([
        CaptureTokenPattern(
          label: "parameters",
          start: Token(value: "("),
          end: Token(value: ")")
        ),
        SingleTokenPattern(Token.Type.SYMBOL, value: "=>"),
        NodeTokenPattern(LocalScopeParser().valueParsers, label: "lambda_contents"),
      ]),
      GroupTokenPattern([
        SingleTokenPattern(Token.Type.IDENTIFIER, label: "param_name"),
        SingleTokenPattern(Token.Type.SYMBOL, value: "=>"),
        NodeTokenPattern(LocalScopeParser().valueParsers, label: "lambda_contents"),
      ])
    ]),
    NodeTokenPattern([LocalScopeParser()], label: "lambda_contents"),
  ])

  override public checkStatementContinuation(ParseContext context, Token token) => true

  override public generateNode(ParseContext context, TokenMatch match = lastMatch) -> LambdaNode {
    return LambdaNode()
  }

  override public getChildNodeTokenMatches(ParseContext context, TokenMatch match) => NodeTokenMatch[] {
    if (let contents = match.getMatch<NodeTokenMatch>("lambda_contents")) {
      return [contents]
    }
  }
}