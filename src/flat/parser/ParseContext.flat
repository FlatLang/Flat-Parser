package flat/parser

import flat/parser/parsers
import flat/parser/matchers
import flat/ast
import flat/datastruct/list/Stack
import flat/compiler/models/Token
import flat/io/File
import flat/log/Logger
import flat/stream/Stream

data class {
  static Logger log = Logger(ParseContext.class)

  visible Stack<Node> parentStack = Stack()
  visible Stack<ParserBase> parserStack = Stack()
  visible Stack<Array<ParserBase>> parsersStack = Stack()
  visible var Stack<Node> statementParentStack = Stack()
  visible var Node currentNode
  visible var ParserBase currentParser
  visible var ParserBase[] currentParsers = ParserBase[]
  visible var Token[] tokens = Token[]
  visible var AnnotationNode[] annotations = AnnotationNode[]

  visible FileNode fileNode => parentStack.toArray().firstWhere({ _.class.isOfType(FileNode.class) })

  public resetCurrentScope() {
    currentNode = parentStack.peek()
    currentParser = parserStack.peek()
    currentParsers = parsersStack.peek()
    statementParentStack = parentStack.copy()
    annotations = Annotation[]
    ParseContext.log.debugFunc({"|
      Reset current scope
        currentNode: #{currentNode.class.name}
        currentParser: #{currentParser.class.name}
        currentParsers: [#{currentParsers.map(p => p.class.name).join(", ")}]
      |"})
  }

  public pushScope(ParserBase parser, Node node) {
    currentNode = parentStack.push(node)
    currentParser = parserStack.push(parser)
    currentParsers = parsersStack.push(parser.childParsers)
    ParseContext.log.debugFunc({"|
      Pushed node to parent stack
        parser: #{parser.class.name}
        currentNode: #{currentNode.class.name}
        currentParser: #{currentParser.class.name}
        currentParsers: [#{currentParsers.map(p => p.class.name).join(", ")}]
      |"})
  }

  public popScope(Token token = null) {
    if (parentStack.count > 1) {
      let popped = parentStack.peek()
      currentNode = parentStack:pop().peek()
      currentParser = parserStack:pop().peek()
      currentParsers = parsersStack:pop().peek()
      ParseContext.log.debugFunc({"|
        Popped node from parent stack
          popped: #{popped.class.name}
          currentNode: #{currentNode.class.name}
          currentParser: #{currentParser.class.name}
          currentParsers: [#{currentParsers.map(p => p.class.name).join(", ")}]
        |"})

      let shouldPop = (
        currentNode.class.isOfType(FunctionNode.class) ||
        currentNode.class.isOfType(ClassNode.class) ||
        currentNode.class.isOfType(MatchNode.class) ||
        currentNode.class.isOfType(WhileLoopNode.class) ||
        currentNode.class.isOfType(ForLoopNode.class) ||
        currentNode.class.isOfType(FieldNode.class) ||
        currentNode.class.isOfType(FieldAccessorFunctionNode.class) ||
        currentNode.class.isOfType(FieldMutatorFunctionNode.class)
      )

      if (shouldPop) {
        popScope(token)
      }
    } else if (token) {
      ParseContext.log.errorFunc({"Unexpected '}' at #{token.location.lineNumber}:#{token.location.column}"})
    } else {
      ParseContext.log.errorFunc({"Unexpected end of scope"})
    }
  }

  public updateScopeForNode(ParserBase parser, Node node) {
    annotations = Annotation[]

    match node.class {
      FileNode.class => fallthrough
      FileScopeNode.class => fallthrough
      ClassNode.class => fallthrough
      ClassScopeNode.class => fallthrough
      FunctionNode.class => fallthrough
      LocalScopeNode.class => fallthrough
      MatchNode.class => fallthrough
      MatchScopeNode.class => fallthrough
      WhileLoopNode.class => fallthrough
      ForLoopNode.class => fallthrough
      FieldNode.class => fallthrough
      FieldScopeNode.class => fallthrough
      FieldAccessorFunctionNode.class => fallthrough
      FieldMutatorFunctionNode.class => fallthrough
      ScopeNode.class => pushScope(parser, node)
      default => {
        if (let childParsers = parser.childParsers) {
          setChildParsers(parser, node, childParsers)
        }
      }
    }
  }

  public setChildParsers(ParserBase parser, Node node, ParserBase[] childParsers) {
    ParseContext.log.debugFunc({"|
      Setting child parsers
        parser: #{parser.class.name}
        node: #{node.class.name}
        childParsers: [#{childParsers.map(p => p.class.name).join(", ")}]
      |"})
    currentNode = node
    currentParser = parser
    currentParsers = childParsers
    statementParentStack = statementParentStack.copy():push(currentNode)
  }
}