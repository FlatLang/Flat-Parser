package flat/parser

import flat/datastruct/HashMap
import flat/parser/Parser
import flat/annotations/VisibleModifier
import flat/annotations/PublicModifier
import flat/annotations/PrivateModifier
import flat/annotations/LetModifier
import flat/annotations/VarModifier
import flat/ast/FileNode
import flat/ast/PackageNode
import flat/compiler/models/Token
import flat/io/File

testable class {
  async test `can match parentheses capture`() {
    let matcherGroup = CaptureTokenMatcher(
      start: Token(value: "("),
      end: Token(value: ")")
    )

    let result = matcherGroup.matches([
      Token(value: "(", type: Token.Type.SYMBOL),
      Token(value: "hey", type: Token.Type.IDENTIFIER),
      Token(value: ")", type: Token.Type.SYMBOL)
    ])

    let expected = CaptureTokenMatch(
      tokens:[
        Token(value: "(", type: Token.Type.SYMBOL),
        Token(value: "hey", type: Token.Type.IDENTIFIER),
        Token(value: ")", type: Token.Type.SYMBOL)
      ],
      capture: [Token(value: "hey", type: Token.Type.IDENTIFIER)],
      partial: false
    )

    expect(result).toBe(expected)
  }

  async test `can match partial parentheses capture no with contents`() {
    let matcherGroup = CaptureTokenMatcher(
      start: Token(value: "("),
      end: Token(value: ")")
    )

    let result = matcherGroup.matches([
      Token(value: "(", type: Token.Type.SYMBOL)
    ])

    let expected = CaptureTokenMatch(
      tokens: [Token(value: "(", type: Token.Type.SYMBOL)],
      capture: Array(),
      partial: true
    )

    expect(result).toBe(expected)
  }

  async test `can match partial parentheses capture with contents`() {
    let matcherGroup = CaptureTokenMatcher(
      start: Token(value: "("),
      end: Token(value: ")")
    )

    let result = matcherGroup.matches([
      Token(value: "(", type: Token.Type.SYMBOL),
      Token(value: "hey", type: Token.Type.IDENTIFIER)
    ])

    let expected = CaptureTokenMatch(
      tokens: [
        Token(value: "(", type: Token.Type.SYMBOL),
        Token(value: "hey", type: Token.Type.IDENTIFIER)
      ],
      capture: [Token(value: "hey", type: Token.Type.IDENTIFIER)],
      partial: true
    )

    expect(result).toBe(expected)
  }

  async test `can match partial parentheses capture with nested parentheses contents`() {
    let matcherGroup = CaptureTokenMatcher(
      start: Token(value: "("),
      end: Token(value: ")")
    )

    let result = matcherGroup.matches([
      Token(value: "(", type: Token.Type.SYMBOL),
      Token(value: "hey", type: Token.Type.IDENTIFIER),
      Token(value: "(", type: Token.Type.SYMBOL),
      Token(value: "(", type: Token.Type.SYMBOL),
      Token(value: "(", type: Token.Type.SYMBOL)
    ])

    let expected = CaptureTokenMatch(
      tokens: [
        Token(value: "(", type: Token.Type.SYMBOL),
        Token(value: "hey", type: Token.Type.IDENTIFIER),
        Token(value: "(", type: Token.Type.SYMBOL),
        Token(value: "(", type: Token.Type.SYMBOL),
        Token(value: "(", type: Token.Type.SYMBOL)
      ],
      capture: [
        Token(value: "hey", type: Token.Type.IDENTIFIER),
        Token(value: "(", type: Token.Type.SYMBOL),
        Token(value: "(", type: Token.Type.SYMBOL),
        Token(value: "(", type: Token.Type.SYMBOL)
      ],
      partial: true
    )

    expect(result).toBe(expected)
  }
}
