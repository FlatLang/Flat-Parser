package flat/parser

import flat/annotations/LetModifier
import flat/compiler/models/Token
import flat/ast/Node
import flat/ast/AnnotationNode
import flat/ast/ClassNode
import flat/ast/ClassScopeNode
import flat/ast/FunctionNode
import flat/ast/FunctionScopeNode
import flat/ast/FileNode
import flat/ast/FieldNode
import flat/ast/FunctionCallNode
import flat/ast/PackageNode
import flat/ast/IdentifierNode
import flat/stream/Stream
import flat/io/File

testable class {
  async test `can consume a token`() {
    let fileNode = FileNode(file: File("Test.flat"))
    let stream = Stream(true)
    let engine = ParseEngine(fileNode, stream)

    engine.consume(Token(value: "package", type: Token.Type.IDENTIFIER))

    expect(engine.getCurrentMatches().mapNotNull({ _.lastMatch })).toBe(Array())
  }

  async test `can find a package match`() {
    let fileNode = FileNode(file: File("Test.flat"))
    let stream = Stream(true)
    let engine = ParseEngine(fileNode, stream)

    engine.consume(Token(value: "package", type: Token.Type.IDENTIFIER))
    engine.consume(Token(value: "test", type: Token.Type.IDENTIFIER))

    expect(engine.getCurrentMatches().mapNotNull({ _.lastMatch })).toBe([
      GroupTokenMatch(
        tokens: [
          Token(value: "package", type: Token.Type.IDENTIFIER),
          Token(value: "test", type: Token.Type.IDENTIFIER)
        ],
        tokenMatches: [
          SingleTokenMatch(
            tokens: [Token(value: "package", type: Token.Type.IDENTIFIER)]
          ),
          SingleTokenMatch(
            tokens: [Token(value: "test", type: Token.Type.IDENTIFIER)],
            label: "package_location_component"
          )
        ]
      )
    ])
  }

  async test `does not return package match once the next token breaks the parser matcher`() {
    let fileNode = FileNode(file: File("Test.flat"))
    let stream = Stream(true)
    let engine = ParseEngine(fileNode, stream)

    engine.consume(Token(value: "package", type: Token.Type.IDENTIFIER))
    engine.consume(Token(value: "test", type: Token.Type.IDENTIFIER))
    engine.consume(Token(value: "import", type: Token.Type.IDENTIFIER))

    expect(engine.getCurrentMatches().mapNotNull({ _.lastMatch })).toBe(Array())
  }

  async test `returns valid package match once the next token breaks the parser matcher`() {
    let fileNode = FileNode(file: File("Test.flat"))
    let stream = Stream(true)
    let engine = ParseEngine(fileNode, stream)

    engine.consume(Token(value: "package", type: Token.Type.IDENTIFIER))
    engine.consume(Token(value: "test", type: Token.Type.IDENTIFIER))

    expect(engine.getValidMatches().mapNotNull({ _.lastMatch })).toBe([
      GroupTokenMatch(
        tokens: [
          Token(value: "package", type: Token.Type.IDENTIFIER),
          Token(value: "test", type: Token.Type.IDENTIFIER)
        ],
        tokenMatches: [
          SingleTokenMatch(
            tokens: [Token(value: "package", type: Token.Type.IDENTIFIER)]
          ),
          SingleTokenMatch(
            tokens: [Token(value: "test", type: Token.Type.IDENTIFIER)],
            label: "package_location_component"
          )
        ]
      )
    ])

    engine.consume(Token(value: "import", type: Token.Type.IDENTIFIER))

    expect(engine.getCurrentMatches().mapNotNull({ _.lastMatch })).toBe(Array())
  }

  async test `emits node after valid package match once the next token breaks the parser matcher`() {
    let fileNode = FileNode(file: File("Test.flat"))
    let stream = Stream(true)
    let engine = ParseEngine(fileNode, stream)

    var Node node = null

    stream.on<Node>("data", { node = _ })

    engine.consume(Token(value: "package", type: Token.Type.IDENTIFIER))
    engine.consume(Token(value: "test", type: Token.Type.IDENTIFIER))

    expect(node).toBe(null)

    engine.consume(Token(value: "import", type: Token.Type.IDENTIFIER))

    expect(node).toBe(PackageNode(location: "test"))
  }

  async test `can parse full package before creating node`() {
    let fileNode = FileNode(file: File("Test.flat"))
    let stream = Stream(true)
    let engine = ParseEngine(fileNode, stream)

    var Node node = null

    stream.on<Node>("data", { node = _ })

    engine.consume(Token(value: "package", type: Token.Type.IDENTIFIER))
    engine.consume(Token(value: "test", type: Token.Type.IDENTIFIER))

    expect(node).toBe(null)

    engine.consume(Token(value: "/", type: Token.Type.SYMBOL))
    engine.consume(Token(value: "test2", type: Token.Type.IDENTIFIER))

    expect(node).toBe(null)

    engine.consume(Token(value: "/", type: Token.Type.SYMBOL))
    engine.consume(Token(value: "test3", type: Token.Type.IDENTIFIER))

    expect(node).toBe(null)

    engine.consume(Token(value: "import", type: Token.Type.IDENTIFIER))

    expect(node).toBe(PackageNode(location: "test/test2/test3"))
  }

  async test `pushes scope to parentStack`() {
    let fileNode = FileNode(file: File("Test.flat"))
    let stream = Stream(true)
    let engine = ParseEngine(fileNode, stream)

    expect(engine.parentStack.count).toBe(2)

    engine.consume(Token(value: "class", type: Token.Type.IDENTIFIER))
    engine.consume(Token(value: "{", type: Token.Type.SYMBOL))

    expect(engine.parentStack.count).toBe(3)

    engine.consume(Token(value: "let", type: Token.Type.IDENTIFIER))

    expect(engine.parentStack.count).toBe(4)
  }

  async test `sets currentNode to latest parsed node`() {
    let fileNode = FileNode(file: File("Test.flat"))
    let stream = Stream(true)
    let engine = ParseEngine(fileNode, stream)

    engine.pushScope(ClassParser(), ClassNode())
    engine.pushScope(ClassScopeParser(), ClassScopeNode())

    engine.consume(Token(value: "let", type: Token.Type.IDENTIFIER))
    engine.consume(Token(value: "String", type: Token.Type.IDENTIFIER))
    engine.consume(Token(value: "thing", type: Token.Type.IDENTIFIER))
    engine.consume(Token(value: "=", type: Token.Type.SYMBOL))

    expect(engine.currentNode).toBe(FieldNode(
      type: "String",
      name: "thing"
    ))
  }

  async test `resets currentNode after latest parsed node statement is ended`() {
    let fileNode = FileNode(file: File("Test.flat"))
    let stream = Stream(true)
    let engine = ParseEngine(fileNode, stream)

    engine.pushScope(ClassParser(), ClassNode())
    engine.pushScope(ClassScopeParser(), ClassScopeNode())

    engine.consume(Token(value: "let", type: Token.Type.IDENTIFIER))
    engine.consume(Token(value: "String", type: Token.Type.IDENTIFIER))
    engine.consume(Token(value: "thing", type: Token.Type.IDENTIFIER))
    engine.consume(Token(value: "aling", type: Token.Type.IDENTIFIER))

    expect(engine.currentNode).toBe(ClassScopeNode())
  }

  async test `can parse successful function call with argument`() {
    let fileNode = FileNode(file: File("Test.flat"))
    let stream = Stream(true)
    let engine = ParseEngine(fileNode, stream)

    engine.pushScope(ClassParser(), ClassNode())
    engine.pushScope(ClassScopeParser(), ClassScopeNode())
    engine.pushScope(FunctionParser(), FunctionNode())
    engine.pushScope(FunctionScopeParser(), FunctionScopeNode())

    var Node node = null

    stream.on<Node>("data", { node = _ })

    engine.consume(Token(value: "test", type: Token.Type.IDENTIFIER))
    engine.consume(Token(value: "(", type: Token.Type.SYMBOL))
    engine.consume(Token(value: "aoeu", type: Token.Type.IDENTIFIER))
    engine.consume(Token(value: ")", type: Token.Type.SYMBOL))
    engine.consume(Token(value: "let", type: Token.Type.IDENTIFIER))
    engine.consume(Token(value: "str", type: Token.Type.IDENTIFIER))

    expect(node).toBe(
      FunctionCallNode(
        name: "test",
        children: [
          IdentifierNode(
            name: "aoeu"
          )
        ]
      )
    )
  }

  async test `resets parsers after successful function call parse`() {
    let fileNode = FileNode(file: File("Test.flat"))
    let stream = Stream(true)
    let engine = ParseEngine(fileNode, stream)

    engine.pushScope(ClassParser(), ClassNode())
    engine.pushScope(ClassScopeParser(), ClassScopeNode())
    engine.pushScope(FunctionParser(), FunctionNode())
    engine.pushScope(FunctionScopeParser(), FunctionScopeNode())

    var Node node = null

    stream.on<Node>("data", { node = _ })

    engine.consume(Token(value: "test", type: Token.Type.IDENTIFIER))
    engine.consume(Token(value: "(", type: Token.Type.SYMBOL))
    engine.consume(Token(value: "aoeu", type: Token.Type.IDENTIFIER))
    engine.consume(Token(value: ")", type: Token.Type.SYMBOL))
    engine.consume(Token(value: "let", type: Token.Type.IDENTIFIER))
    engine.consume(Token(value: "str", type: Token.Type.IDENTIFIER))

    expect(engine.currentNode).toBe(FunctionScopeNode())
  }
}
