package flat/parser

import flat/parser/parsers
import flat/parser/matchers
import flat/ast
import flat/annotations
import flat/compiler/models/Token
import flat/lexer/Lexer
import flat/io/File

testable class {
  async test `can parse function call with complex lambda`() {
    let source = "|
      class {
        func() {
          source.forEach((Pair<String, Object> pair) => {
            if (!dest.containsKey(pair.key)) {
              dest[pair.key] = pair.value
            }

            if (pair.value.class.isOfType(HashMap.class)) {
              let HashMap<String, Object> hashmap = (HashMap)pair.value
              let HashMap<String, Object> existingHashmap = (HashMap)dest[pair.key]
              merge(hashmap, existingHashmap)
            } else {
              dest[pair.key] = pair.value
            }
          })
        }
      }
      |"

    let file = File("Test.flat")
    let stream = Parser().parse(file, Lexer().lex(source))

    let nodes = Node[]

    stream.on<Node>("data", { nodes.add(_) })

    expect(nodes).toBe([
      FileNode(file: file),
      ClassNode(name: "Test", implicitName: true),
      ClassScopeNode(),
      FunctionNode(name: "func"),
      LocalScopeNode(),
      IdentifierNode(name: "source"),
      DotAccessNode(),
      FunctionCallNode(name: "forEach"),
      LambdaNode(),
      IfNode(),
      LocalScopeNode(),
      IdentifierNode(name: "dest"),
      ArrayAccessNode(),
      IdentifierNode(name: "pair"),
      DotAccessNode(),
      IdentifierNode(name: "key"),
      AssignmentNode(),
      IdentifierNode(name: "pair"),
      DotAccessNode(),
      IdentifierNode(name: "value"),
      IfNode(),
      LocalScopeNode(),
      LocalDeclarationNode(type: "HashMap", name: "hashmap"),
      AssignmentNode(),
      CastNode(type: "HashMap"),
      IdentifierNode(name: "pair"),
      DotAccessNode(),
      IdentifierNode(name: "value"),
      LocalDeclarationNode(type: "HashMap", name: "existingHashmap"),
      AssignmentNode(),
      CastNode(type: "HashMap"),
      IdentifierNode(name: "dest"),
      ArrayAccessNode(),
      IdentifierNode(name: "pair"),
      DotAccessNode(),
      IdentifierNode(name: "key"),
      FunctionCallNode(name: "merge"),
      IdentifierNode(name: "hashmap"),
      ElseNode(),
      LocalScopeNode(),
      IdentifierNode(name: "dest"),
      ArrayAccessNode(),
      IdentifierNode(name: "pair"),
      DotAccessNode(),
      IdentifierNode(name: "key"),
      AssignmentNode(),
      IdentifierNode(name: "pair"),
      DotAccessNode(),
      IdentifierNode(name: "value")
    ])
  }
}
